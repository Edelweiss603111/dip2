/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.9.0 (NJsonSchema v9.10.9.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpParams } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AboutClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Getting version information without aithorization
     * @return T:Jade.Api.Models.About.AboutResponce
     */
    aboutGet(): Observable<AboutResponce | null> {
        let url_ = this.baseUrl + "/api/About/AboutGet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processAboutGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processAboutGet(response_);
                } catch (e) {
                    return <Observable<AboutResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AboutResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processAboutGet(response: HttpResponse<Blob>): Observable<AboutResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AboutResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AboutResponce | null>(<any>null);
    }

    /**
     * Getting version information with aithorization
     * @return T:Jade.Api.Models.About.AboutResponce
     */
    aboutPost(): Observable<AboutResponce | null> {
        let url_ = this.baseUrl + "/api/About/AboutPost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAboutPost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processAboutPost(response_);
                } catch (e) {
                    return <Observable<AboutResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AboutResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processAboutPost(response: HttpResponse<Blob>): Observable<AboutResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AboutResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AboutResponce | null>(<any>null);
    }

    /**
     * Always generates error with specified
     * @meaasge error message
     */
    getException(meaasge: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/About/GetException?";
        if (meaasge === undefined)
            throw new Error("The parameter 'meaasge' must be defined.");
        else
            url_ += "meaasge=" + encodeURIComponent("" + meaasge) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetException(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetException(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGetException(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Always generates error with specified
     * @meaasge (optional) error message
     */
    postException(meaasge: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/About/PostException";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(meaasge);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processPostException(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processPostException(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processPostException(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    login(model: LoginRequest | null): Observable<SignInResult | null> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processLogin(response_);
                } catch (e) {
                    return <Observable<SignInResult | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<SignInResult | null>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponse<Blob>): Observable<SignInResult | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SignInResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SignInResult | null>(<any>null);
    }

    register(model: RegisterRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegister(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    registerEmployee(email: string | null, cashdeskId: number): Observable<GetUserAndCardResponse | null> {
        let url_ = this.baseUrl + "/api/Account/RegisterEmployee?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processRegisterEmployee(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterEmployee(response_);
                } catch (e) {
                    return <Observable<GetUserAndCardResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserAndCardResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processRegisterEmployee(response: HttpResponse<Blob>): Observable<GetUserAndCardResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserAndCardResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetUserAndCardResponse | null>(<any>null);
    }

    resetPassword(user: User | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processResetPassword(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    addUserToInstallation(userId: number, cashdeskId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/AddUserToInstallation?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processAddUserToInstallation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processAddUserToInstallation(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddUserToInstallation(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    changeRole(userId: number, isCashier: boolean, isHeadCashier: boolean, isAdmin: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/ChangeRole?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (isCashier === undefined || isCashier === null)
            throw new Error("The parameter 'isCashier' must be defined and cannot be null.");
        else
            url_ += "isCashier=" + encodeURIComponent("" + isCashier) + "&"; 
        if (isHeadCashier === undefined || isHeadCashier === null)
            throw new Error("The parameter 'isHeadCashier' must be defined and cannot be null.");
        else
            url_ += "isHeadCashier=" + encodeURIComponent("" + isHeadCashier) + "&"; 
        if (isAdmin === undefined || isAdmin === null)
            throw new Error("The parameter 'isAdmin' must be defined and cannot be null.");
        else
            url_ += "isAdmin=" + encodeURIComponent("" + isAdmin) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processChangeRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processChangeRole(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeRole(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    changeName(userId: number, displayName: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/ChangeName?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (displayName === undefined)
            throw new Error("The parameter 'displayName' must be defined.");
        else
            url_ += "displayName=" + encodeURIComponent("" + displayName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processChangeName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processChangeName(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeName(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    grantCard(userId: number, uid: string | null, installationId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Account/GrantCard?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGrantCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGrantCard(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGrantCard(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    sendEmailConfirmation(): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/SendEmailConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendEmailConfirmation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSendEmailConfirmation(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processSendEmailConfirmation(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    changeEmail(emailInfo: ChangeEmailRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/ChangeEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(emailInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processChangeEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processChangeEmail(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processChangeEmail(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    logout(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLogout(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processLogout(response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processLogout(response: HttpResponse<Blob>): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.body, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    localeProfile(): Observable<LocaleProfileResponce | null> {
        let url_ = this.baseUrl + "/api/Account/LocaleProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLocaleProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processLocaleProfile(response_);
                } catch (e) {
                    return <Observable<LocaleProfileResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<LocaleProfileResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processLocaleProfile(response: HttpResponse<Blob>): Observable<LocaleProfileResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocaleProfileResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LocaleProfileResponce | null>(<any>null);
    }

    getUserData(): Observable<UserData | null> {
        let url_ = this.baseUrl + "/api/Account/GetUserData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUserData(response_);
                } catch (e) {
                    return <Observable<UserData | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserData | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUserData(response: HttpResponse<Blob>): Observable<UserData | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserData.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserData | null>(<any>null);
    }

    updateUserData(entity: UserData | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Account/UpdateUserData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUserData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdateUserData(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserData(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getIdentityData(): Observable<IdentityDataResopnce | null> {
        let url_ = this.baseUrl + "/api/Account/GetIdentityData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetIdentityData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetIdentityData(response_);
                } catch (e) {
                    return <Observable<IdentityDataResopnce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<IdentityDataResopnce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetIdentityData(response: HttpResponse<Blob>): Observable<IdentityDataResopnce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdentityDataResopnce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<IdentityDataResopnce | null>(<any>null);
    }

    removeLogin(loginInfo: UserLoginInfo | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRemoveLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRemoveLogin(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processRemoveLogin(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    setPhone(setPhoneRequest: SetPhoneRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/SetPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setPhoneRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetPhone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetPhone(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processSetPhone(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    confirmPhoneNumber(info: ConfirmPhoneRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/ConfirmPhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processConfirmPhoneNumber(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processConfirmPhoneNumber(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processConfirmPhoneNumber(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    changePassword(info: ChangePasswordRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processChangePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processChangePassword(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processChangePassword(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }

    createPassword(info: CreatePasswordRequest | null): Observable<ResultBaseOfBoolean | null> {
        let url_ = this.baseUrl + "/api/Account/CreatePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreatePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCreatePassword(response_);
                } catch (e) {
                    return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultBaseOfBoolean | null>><any>Observable.throw(response_);
        });
    }

    protected processCreatePassword(response: HttpResponse<Blob>): Observable<ResultBaseOfBoolean | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultBaseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResultBaseOfBoolean | null>(<any>null);
    }
}

@Injectable()
export class AccountProcessingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    hold(time: Date, cardUid: string | null, accountTypeId: number, amount: number): Observable<AccountProcessingTransaction | null> {
        let url_ = this.baseUrl + "/api/AccountProcessing/Hold?";
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (cardUid === undefined)
            throw new Error("The parameter 'cardUid' must be defined.");
        else
            url_ += "cardUid=" + encodeURIComponent("" + cardUid) + "&"; 
        if (accountTypeId === undefined || accountTypeId === null)
            throw new Error("The parameter 'accountTypeId' must be defined and cannot be null.");
        else
            url_ += "accountTypeId=" + encodeURIComponent("" + accountTypeId) + "&"; 
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processHold(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processHold(response_);
                } catch (e) {
                    return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(response_);
        });
    }

    protected processHold(response: HttpResponse<Blob>): Observable<AccountProcessingTransaction | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountProcessingTransaction.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AccountProcessingTransaction | null>(<any>null);
    }

    cancel(time: Date, transactionId: number, comment: string | null): Observable<AccountProcessingTransaction | null> {
        let url_ = this.baseUrl + "/api/AccountProcessing/Cancel?";
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else
            url_ += "comment=" + encodeURIComponent("" + comment) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCancel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCancel(response_);
                } catch (e) {
                    return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(response_);
        });
    }

    protected processCancel(response: HttpResponse<Blob>): Observable<AccountProcessingTransaction | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountProcessingTransaction.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AccountProcessingTransaction | null>(<any>null);
    }

    get(transactionId: number): Observable<AccountProcessingTransaction | null> {
        let url_ = this.baseUrl + "/api/AccountProcessing/Get?";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountProcessingTransaction | null>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponse<Blob>): Observable<AccountProcessingTransaction | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountProcessingTransaction.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AccountProcessingTransaction | null>(<any>null);
    }

    process(time: Date, transactionId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AccountProcessing/Process?";
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processProcess(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processProcess(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processProcess(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CalendarsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getDays(calendarId: number, from: Date, to: Date): Observable<CalendarDay[] | null> {
        let url_ = this.baseUrl + "/api/Calendars/GetDays?";
        if (calendarId === undefined || calendarId === null)
            throw new Error("The parameter 'calendarId' must be defined and cannot be null.");
        else
            url_ += "calendarId=" + encodeURIComponent("" + calendarId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDays(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetDays(response_);
                } catch (e) {
                    return <Observable<CalendarDay[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CalendarDay[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetDays(response: HttpResponse<Blob>): Observable<CalendarDay[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CalendarDay.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CalendarDay[] | null>(<any>null);
    }

    setDay(calendarDay: CalendarDay | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Calendars/SetDay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(calendarDay);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSetDay(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetDay(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processSetDay(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    insert(entity: Calendar | null): Observable<Calendar | null> {
        let url_ = this.baseUrl + "/api/Calendars/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Calendar | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Calendar | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Calendar | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Calendar.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Calendar | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Calendars/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Calendar | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Calendars/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: CalendarsSelectRequest | null): Observable<CalendarsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Calendars/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<CalendarsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CalendarsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<CalendarsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CalendarsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CalendarsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<CalendarView | null> {
        let url_ = this.baseUrl + "/api/Calendars/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<CalendarView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CalendarView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<CalendarView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CalendarView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CalendarView | null>(<any>null);
    }
}

@Injectable()
export class CashdeskPrintersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getModels(driver: CashdeskPrinterDriver): Observable<CashdeskPrinterModel[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/GetModels?";
        if (driver === undefined || driver === null)
            throw new Error("The parameter 'driver' must be defined and cannot be null.");
        else
            url_ += "driver=" + encodeURIComponent("" + driver) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetModels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetModels(response_);
                } catch (e) {
                    return <Observable<CashdeskPrinterModel[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPrinterModel[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetModels(response: HttpResponse<Blob>): Observable<CashdeskPrinterModel[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskPrinterModel.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPrinterModel[] | null>(<any>null);
    }

    insert(entity: CashdeskPrinter | null): Observable<CashdeskPrinter | null> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<CashdeskPrinter | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPrinter | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<CashdeskPrinter | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdeskPrinter.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPrinter | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: CashdeskPrinter | null): Observable<number> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: CashdeskPrintersSelectRequest | null): Observable<CashdeskPrintersSelectResponce | null> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<CashdeskPrintersSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPrintersSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<CashdeskPrintersSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdeskPrintersSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPrintersSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<CashdeskPrinterView | null> {
        let url_ = this.baseUrl + "/api/CashdeskPrinters/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<CashdeskPrinterView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPrinterView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<CashdeskPrinterView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdeskPrinterView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPrinterView | null>(<any>null);
    }
}

@Injectable()
export class CashdesksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    goodTypes(cashdeskId: number, canWrite: boolean): Observable<CashdeskToGoodTypeView[] | null> {
        let url_ = this.baseUrl + "/api/Cashdesks/GoodTypes?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (canWrite === null)
            throw new Error("The parameter 'canWrite' cannot be null.");
        else if (canWrite !== undefined)
            url_ += "canWrite=" + encodeURIComponent("" + canWrite) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGoodTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGoodTypes(response_);
                } catch (e) {
                    return <Observable<CashdeskToGoodTypeView[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskToGoodTypeView[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGoodTypes(response: HttpResponse<Blob>): Observable<CashdeskToGoodTypeView[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskToGoodTypeView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskToGoodTypeView[] | null>(<any>null);
    }

    setGoodTypeBound(goodTypeBound: CashdeskToGoodTypeView | null): Observable<CashdeskToGoodTypeView | null> {
        let url_ = this.baseUrl + "/api/Cashdesks/SetGoodTypeBound";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(goodTypeBound);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetGoodTypeBound(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetGoodTypeBound(response_);
                } catch (e) {
                    return <Observable<CashdeskToGoodTypeView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskToGoodTypeView | null>><any>Observable.throw(response_);
        });
    }

    protected processSetGoodTypeBound(response: HttpResponse<Blob>): Observable<CashdeskToGoodTypeView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdeskToGoodTypeView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskToGoodTypeView | null>(<any>null);
    }

    deleteGoodTypeBound(cashdeskId: number, goodTypeId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Cashdesks/DeleteGoodTypeBound?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteGoodTypeBound(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteGoodTypeBound(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDeleteGoodTypeBound(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    insert(entity: Cashdesk | null): Observable<Cashdesk | null> {
        let url_ = this.baseUrl + "/api/Cashdesks/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Cashdesk | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Cashdesk | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Cashdesk | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Cashdesk.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Cashdesk | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Cashdesks/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Cashdesk | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Cashdesks/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: CashdesksSelectRequest | null): Observable<CashdesksSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Cashdesks/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<CashdesksSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdesksSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<CashdesksSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdesksSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdesksSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<CashdeskView | null> {
        let url_ = this.baseUrl + "/api/Cashdesks/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<CashdeskView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<CashdeskView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashdeskView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskView | null>(<any>null);
    }
}

@Injectable()
export class CashdeskServerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getServerCurrentTime(): Observable<Date> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetServerCurrentTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServerCurrentTime(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServerCurrentTime(response_);
                } catch (e) {
                    return <Observable<Date>><any>Observable.throw(e);
                }
            } else
                return <Observable<Date>><any>Observable.throw(response_);
        });
    }

    protected processGetServerCurrentTime(response: HttpResponse<Blob>): Observable<Date> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Date>(<any>null);
    }

    getRight(goodId: number): Observable<Right | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetRight?";
        if (goodId === undefined || goodId === null)
            throw new Error("The parameter 'goodId' must be defined and cannot be null.");
        else
            url_ += "goodId=" + encodeURIComponent("" + goodId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRight(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetRight(response_);
                } catch (e) {
                    return <Observable<Right | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Right | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRight(response: HttpResponse<Blob>): Observable<Right | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Right.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Right | null>(<any>null);
    }

    getGoodTypes(cashdeskId: number): Observable<GoodTypeWithQrDeny[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetGoodTypes?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetGoodTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetGoodTypes(response_);
                } catch (e) {
                    return <Observable<GoodTypeWithQrDeny[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeWithQrDeny[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetGoodTypes(response: HttpResponse<Blob>): Observable<GoodTypeWithQrDeny[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GoodTypeWithQrDeny.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeWithQrDeny[] | null>(<any>null);
    }

    getAllGoodTypesForInstallation(installationId: number): Observable<GoodTypeWithQrDeny[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetAllGoodTypesForInstallation?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllGoodTypesForInstallation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAllGoodTypesForInstallation(response_);
                } catch (e) {
                    return <Observable<GoodTypeWithQrDeny[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeWithQrDeny[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllGoodTypesForInstallation(response: HttpResponse<Blob>): Observable<GoodTypeWithQrDeny[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GoodTypeWithQrDeny.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeWithQrDeny[] | null>(<any>null);
    }

    getUnknownGoodType(installationId: number, goodTypeId: number): Observable<GoodType | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetUnknownGoodType?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUnknownGoodType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUnknownGoodType(response_);
                } catch (e) {
                    return <Observable<GoodType | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodType | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUnknownGoodType(response: HttpResponse<Blob>): Observable<GoodType | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodType.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodType | null>(<any>null);
    }

    getGoodsHotKeys(cashdeskId: number): Observable<GoodHotKey[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetGoodsHotKeys?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetGoodsHotKeys(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetGoodsHotKeys(response_);
                } catch (e) {
                    return <Observable<GoodHotKey[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodHotKey[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetGoodsHotKeys(response: HttpResponse<Blob>): Observable<GoodHotKey[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GoodHotKey.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodHotKey[] | null>(<any>null);
    }

    getFrequentlyGoodTypes(cashdeskId: number): Observable<GoodType[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetFrequentlyGoodTypes?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFrequentlyGoodTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetFrequentlyGoodTypes(response_);
                } catch (e) {
                    return <Observable<GoodType[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodType[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFrequentlyGoodTypes(response: HttpResponse<Blob>): Observable<GoodType[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GoodType.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodType[] | null>(<any>null);
    }

    getGoodTypeTrees(): Observable<GoodTypeTree[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetGoodTypeTrees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetGoodTypeTrees(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetGoodTypeTrees(response_);
                } catch (e) {
                    return <Observable<GoodTypeTree[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeTree[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetGoodTypeTrees(response: HttpResponse<Blob>): Observable<GoodTypeTree[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GoodTypeTree.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeTree[] | null>(<any>null);
    }

    getProcessingsByCashdeskId(cashdeskId: number): Observable<Processing[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetProcessingsByCashdeskId?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProcessingsByCashdeskId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetProcessingsByCashdeskId(response_);
                } catch (e) {
                    return <Observable<Processing[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Processing[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetProcessingsByCashdeskId(response: HttpResponse<Blob>): Observable<Processing[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Processing.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Processing[] | null>(<any>null);
    }

    getCardInfoByBoardNumber(boardNumber: string | null): Observable<CardWithInstallation[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCardInfoByBoardNumber?";
        if (boardNumber === undefined)
            throw new Error("The parameter 'boardNumber' must be defined.");
        else
            url_ += "boardNumber=" + encodeURIComponent("" + boardNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCardInfoByBoardNumber(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCardInfoByBoardNumber(response_);
                } catch (e) {
                    return <Observable<CardWithInstallation[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CardWithInstallation[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCardInfoByBoardNumber(response: HttpResponse<Blob>): Observable<CardWithInstallation[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardWithInstallation.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CardWithInstallation[] | null>(<any>null);
    }

    getCardInfo(uid: string | null, cardId: number | null): Observable<CardInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCardInfo?";
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCardInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCardInfo(response_);
                } catch (e) {
                    return <Observable<CardInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CardInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCardInfo(response: HttpResponse<Blob>): Observable<CardInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CardInfoResponse | null>(<any>null);
    }

    getCards(request: GetCardsRequest | null): Observable<GetCardsResponce | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetCards(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCards(response_);
                } catch (e) {
                    return <Observable<GetCardsResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCardsResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCards(response: HttpResponse<Blob>): Observable<GetCardsResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCardsResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetCardsResponce | null>(<any>null);
    }

    getCurrentUserInfo(cashdeskId: number): Observable<CurrentUserInfoResponce | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCurrentUserInfo?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentUserInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCurrentUserInfo(response_);
                } catch (e) {
                    return <Observable<CurrentUserInfoResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CurrentUserInfoResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentUserInfo(response: HttpResponse<Blob>): Observable<CurrentUserInfoResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserInfoResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CurrentUserInfoResponce | null>(<any>null);
    }

    getUser(userId: number): Observable<UserData | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUser(response_);
                } catch (e) {
                    return <Observable<UserData | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserData | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUser(response: HttpResponse<Blob>): Observable<UserData | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserData.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserData | null>(<any>null);
    }

    getUserByCard(uid: string | null, cardId: number | null): Observable<UserData | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetUserByCard?";
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (cardId === undefined)
            throw new Error("The parameter 'cardId' must be defined.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserByCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUserByCard(response_);
                } catch (e) {
                    return <Observable<UserData | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserData | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUserByCard(response: HttpResponse<Blob>): Observable<UserData | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserData.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserData | null>(<any>null);
    }

    getOrCreateRight(cardId: number, clientId: number | null, cashdeskId: number, goodTypeId: number, time: Date): Observable<Right | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetOrCreateRight?";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (clientId === undefined)
            throw new Error("The parameter 'clientId' must be defined.");
        else
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrCreateRight(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetOrCreateRight(response_);
                } catch (e) {
                    return <Observable<Right | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Right | null>><any>Observable.throw(response_);
        });
    }

    protected processGetOrCreateRight(response: HttpResponse<Blob>): Observable<Right | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Right.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Right | null>(<any>null);
    }

    getReturnInfoByCard(uid: string | null, userId: number | null, cashdeskId: number, time: Date, showAdministrative: boolean): Observable<GetReturnInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetReturnInfoByCard?";
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (showAdministrative === undefined || showAdministrative === null)
            throw new Error("The parameter 'showAdministrative' must be defined and cannot be null.");
        else
            url_ += "showAdministrative=" + encodeURIComponent("" + showAdministrative) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetReturnInfoByCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetReturnInfoByCard(response_);
                } catch (e) {
                    return <Observable<GetReturnInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetReturnInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetReturnInfoByCard(response: HttpResponse<Blob>): Observable<GetReturnInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReturnInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetReturnInfoResponse | null>(<any>null);
    }

    getReturnInfoByChecks(request: GetReturnInfoByChecksRequest | null): Observable<GetReturnInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetReturnInfoByChecks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetReturnInfoByChecks(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetReturnInfoByChecks(response_);
                } catch (e) {
                    return <Observable<GetReturnInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetReturnInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetReturnInfoByChecks(response: HttpResponse<Blob>): Observable<GetReturnInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReturnInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetReturnInfoResponse | null>(<any>null);
    }

    getProcessings(): Observable<Processing[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetProcessings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProcessings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetProcessings(response_);
                } catch (e) {
                    return <Observable<Processing[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Processing[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetProcessings(response: HttpResponse<Blob>): Observable<Processing[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Processing.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Processing[] | null>(<any>null);
    }

    getTransactionsByRight(rightId: number): Observable<TransactionView[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetTransactionsByRight?";
        if (rightId === undefined || rightId === null)
            throw new Error("The parameter 'rightId' must be defined and cannot be null.");
        else
            url_ += "rightId=" + encodeURIComponent("" + rightId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionsByRight(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTransactionsByRight(response_);
                } catch (e) {
                    return <Observable<TransactionView[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionView[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionsByRight(response: HttpResponse<Blob>): Observable<TransactionView[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransactionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransactionView[] | null>(<any>null);
    }

    getPrinterSettings(cashdeskId: number): Observable<CashdeskPrinter[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetPrinterSettings?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPrinterSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetPrinterSettings(response_);
                } catch (e) {
                    return <Observable<CashdeskPrinter[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPrinter[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPrinterSettings(response: HttpResponse<Blob>): Observable<CashdeskPrinter[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskPrinter.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPrinter[] | null>(<any>null);
    }

    getCashdesk(id: number): Observable<Cashdesk | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCashdesk?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCashdesk(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCashdesk(response_);
                } catch (e) {
                    return <Observable<Cashdesk | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Cashdesk | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCashdesk(response: HttpResponse<Blob>): Observable<Cashdesk | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Cashdesk.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Cashdesk | null>(<any>null);
    }

    calculatePrice(cashdeskId: number, goodTypeId: number, dateFrom: Date, dateTo: Date): Observable<number> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CalculatePrice?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCalculatePrice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCalculatePrice(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCalculatePrice(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * Returns dict. Key - int GoodTypeId, Value - decimal Price
     * @cashdeskId Cashdesk id to calculatr price
     */
    calculatePrices(cashdeskId: number, dateFrom: Date): Observable<{ [key: string] : number; } | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CalculatePrices?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCalculatePrices(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCalculatePrices(response_);
                } catch (e) {
                    return <Observable<{ [key: string] : number; } | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<{ [key: string] : number; } | null>><any>Observable.throw(response_);
        });
    }

    protected processCalculatePrices(response: HttpResponse<Blob>): Observable<{ [key: string] : number; } | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<{ [key: string] : number; } | null>(<any>null);
    }

    getMinTimeSpan(): Observable<string> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetMinTimeSpan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMinTimeSpan(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetMinTimeSpan(response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processGetMinTimeSpan(response: HttpResponse<Blob>): Observable<string> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string>(<any>null);
    }

    getCashdesks(installationId: number): Observable<Cashdesk[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCashdesks?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCashdesks(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCashdesks(response_);
                } catch (e) {
                    return <Observable<Cashdesk[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Cashdesk[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCashdesks(response: HttpResponse<Blob>): Observable<Cashdesk[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Cashdesk.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Cashdesk[] | null>(<any>null);
    }

    getCashdesksByInstallation(installationId: number): Observable<Cashdesk[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetCashdesksByInstallation?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCashdesksByInstallation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCashdesksByInstallation(response_);
                } catch (e) {
                    return <Observable<Cashdesk[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Cashdesk[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCashdesksByInstallation(response: HttpResponse<Blob>): Observable<Cashdesk[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Cashdesk.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Cashdesk[] | null>(<any>null);
    }

    getDiscountTypes(installationId: number): Observable<DiscountType[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetDiscountTypes?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDiscountTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetDiscountTypes(response_);
                } catch (e) {
                    return <Observable<DiscountType[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DiscountType[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetDiscountTypes(response: HttpResponse<Blob>): Observable<DiscountType[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DiscountType.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DiscountType[] | null>(<any>null);
    }

    calculateDiscounts(request: CalculateDiscountsRequest | null): Observable<CheckEntryDiscount[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CalculateDiscounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCalculateDiscounts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCalculateDiscounts(response_);
                } catch (e) {
                    return <Observable<CheckEntryDiscount[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CheckEntryDiscount[] | null>><any>Observable.throw(response_);
        });
    }

    protected processCalculateDiscounts(response: HttpResponse<Blob>): Observable<CheckEntryDiscount[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CheckEntryDiscount.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CheckEntryDiscount[] | null>(<any>null);
    }

    getReaderSettings(cashdeskId: number): Observable<CardReaderSettings[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetReaderSettings?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetReaderSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetReaderSettings(response_);
                } catch (e) {
                    return <Observable<CardReaderSettings[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CardReaderSettings[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetReaderSettings(response: HttpResponse<Blob>): Observable<CardReaderSettings[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardReaderSettings.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CardReaderSettings[] | null>(<any>null);
    }

    validateDiscountCardCode(cardCode: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CashdeskServer/ValidateDiscountCardCode?";
        if (cardCode === undefined)
            throw new Error("The parameter 'cardCode' must be defined.");
        else
            url_ += "cardCode=" + encodeURIComponent("" + cardCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processValidateDiscountCardCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processValidateDiscountCardCode(response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processValidateDiscountCardCode(response: HttpResponse<Blob>): Observable<boolean> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<boolean>(<any>null);
    }

    getChecksByGoods(request: GetChecksByGoodsRequest | null): Observable<GetChecksByGoodsResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetChecksByGoods";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetChecksByGoods(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetChecksByGoods(response_);
                } catch (e) {
                    return <Observable<GetChecksByGoodsResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetChecksByGoodsResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetChecksByGoods(response: HttpResponse<Blob>): Observable<GetChecksByGoodsResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetChecksByGoodsResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetChecksByGoodsResponse | null>(<any>null);
    }

    getUserAndCardByEmail(email: string | null, installationId: number): Observable<GetUserAndCardResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetUserAndCardByEmail?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserAndCardByEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUserAndCardByEmail(response_);
                } catch (e) {
                    return <Observable<GetUserAndCardResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserAndCardResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUserAndCardByEmail(response: HttpResponse<Blob>): Observable<GetUserAndCardResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserAndCardResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetUserAndCardResponse | null>(<any>null);
    }

    getTransactionsByCard(cardId: number, clientId: number | null, installationId: number): Observable<TransactionView[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetTransactionsByCard?";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (clientId === undefined)
            throw new Error("The parameter 'clientId' must be defined.");
        else
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionsByCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTransactionsByCard(response_);
                } catch (e) {
                    return <Observable<TransactionView[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionView[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionsByCard(response: HttpResponse<Blob>): Observable<TransactionView[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransactionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransactionView[] | null>(<any>null);
    }

    getClientInfo(userId: number | null, uid: string | null, installationId: number): Observable<GetClientInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetClientInfo?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetClientInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetClientInfo(response_);
                } catch (e) {
                    return <Observable<GetClientInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetClientInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetClientInfo(response: HttpResponse<Blob>): Observable<GetClientInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetClientInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetClientInfoResponse | null>(<any>null);
    }

    getInstallations(): Observable<Installation[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetInstallations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallations(response_);
                } catch (e) {
                    return <Observable<Installation[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Installation[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallations(response: HttpResponse<Blob>): Observable<Installation[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Installation.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Installation[] | null>(<any>null);
    }

    getInstallation(id: number): Observable<Installation | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetInstallation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallation(response_);
                } catch (e) {
                    return <Observable<Installation | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Installation | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallation(response: HttpResponse<Blob>): Observable<Installation | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Installation.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Installation | null>(<any>null);
    }

    getShift(cashdeskId: number): Observable<ShiftResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetShift?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetShift(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetShift(response_);
                } catch (e) {
                    return <Observable<ShiftResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShiftResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetShift(response: HttpResponse<Blob>): Observable<ShiftResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShiftResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShiftResponse | null>(<any>null);
    }

    getPosDisplaySettings(cashdeskId: number): Observable<PosDisplaySettings | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetPosDisplaySettings?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPosDisplaySettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetPosDisplaySettings(response_);
                } catch (e) {
                    return <Observable<PosDisplaySettings | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PosDisplaySettings | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPosDisplaySettings(response: HttpResponse<Blob>): Observable<PosDisplaySettings | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PosDisplaySettings.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PosDisplaySettings | null>(<any>null);
    }

    getTariffs(from: Date, installationId: number): Observable<Tariff[] | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetTariffs?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTariffs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTariffs(response_);
                } catch (e) {
                    return <Observable<Tariff[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tariff[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTariffs(response: HttpResponse<Blob>): Observable<Tariff[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Tariff.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Tariff[] | null>(<any>null);
    }

    generateQr(cardId: number): Observable<string | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GenerateQr?";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGenerateQr(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGenerateQr(response_);
                } catch (e) {
                    return <Observable<string | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string | null>><any>Observable.throw(response_);
        });
    }

    protected processGenerateQr(response: HttpResponse<Blob>): Observable<string | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string | null>(<any>null);
    }

    getPublicKey(): Observable<RsaKey | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetPublicKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPublicKey(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetPublicKey(response_);
                } catch (e) {
                    return <Observable<RsaKey | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<RsaKey | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPublicKey(response: HttpResponse<Blob>): Observable<RsaKey | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RsaKey.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RsaKey | null>(<any>null);
    }

    getNextCheckId(): Observable<number> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetNextCheckId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetNextCheckId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetNextCheckId(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetNextCheckId(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getInstallationUser(userId: number, installationId: number): Observable<InstallationUser | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetInstallationUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallationUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallationUser(response_);
                } catch (e) {
                    return <Observable<InstallationUser | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationUser | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallationUser(response: HttpResponse<Blob>): Observable<InstallationUser | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationUser.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationUser | null>(<any>null);
    }

    getPeper(installationId: number, cashdeskId: number): Observable<SpicesBasket | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GetPeper?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPeper(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetPeper(response_);
                } catch (e) {
                    return <Observable<SpicesBasket | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<SpicesBasket | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPeper(response: HttpResponse<Blob>): Observable<SpicesBasket | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpicesBasket.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SpicesBasket | null>(<any>null);
    }

    openShift(cashdeskId: number): Observable<ShiftResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/OpenShift?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processOpenShift(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processOpenShift(response_);
                } catch (e) {
                    return <Observable<ShiftResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShiftResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processOpenShift(response: HttpResponse<Blob>): Observable<ShiftResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShiftResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShiftResponse | null>(<any>null);
    }

    closeShift(shiftId: number): Observable<ShiftResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CloseShift?";
        if (shiftId === undefined || shiftId === null)
            throw new Error("The parameter 'shiftId' must be defined and cannot be null.");
        else
            url_ += "shiftId=" + encodeURIComponent("" + shiftId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processCloseShift(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCloseShift(response_);
                } catch (e) {
                    return <Observable<ShiftResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShiftResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processCloseShift(response: HttpResponse<Blob>): Observable<ShiftResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShiftResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShiftResponse | null>(<any>null);
    }

    generateCard(cashdeskId: number, installationId: number): Observable<CardInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/GenerateCard?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processGenerateCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGenerateCard(response_);
                } catch (e) {
                    return <Observable<CardInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CardInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGenerateCard(response: HttpResponse<Blob>): Observable<CardInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CardInfoResponse | null>(<any>null);
    }

    createNewUser(): Observable<number> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CreateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processCreateNewUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCreateNewUser(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateNewUser(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    createOrUpdateCard(uid: string | null, boardNumber: string | null, userId: number | null, goodTypeId: number | null, installationId: number): Observable<CardInfoResponse | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/CreateOrUpdateCard?";
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (boardNumber === undefined)
            throw new Error("The parameter 'boardNumber' must be defined.");
        else
            url_ += "boardNumber=" + encodeURIComponent("" + boardNumber) + "&"; 
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (goodTypeId === undefined)
            throw new Error("The parameter 'goodTypeId' must be defined.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCreateOrUpdateCard(response_);
                } catch (e) {
                    return <Observable<CardInfoResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CardInfoResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateCard(response: HttpResponse<Blob>): Observable<CardInfoResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardInfoResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CardInfoResponse | null>(<any>null);
    }

    putCheck(request: PutCheckRequest | null): Observable<PutCheckResponce | null> {
        let url_ = this.baseUrl + "/api/CashdeskServer/PutCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processPutCheck(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processPutCheck(response_);
                } catch (e) {
                    return <Observable<PutCheckResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PutCheckResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processPutCheck(response: HttpResponse<Blob>): Observable<PutCheckResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PutCheckResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PutCheckResponce | null>(<any>null);
    }

    tryRemoveUnconfirmedRights(rightIds: number[] | null): Observable<void> {
        let url_ = this.baseUrl + "/api/CashdeskServer/TryRemoveUnconfirmedRights";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rightIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processTryRemoveUnconfirmedRights(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processTryRemoveUnconfirmedRights(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTryRemoveUnconfirmedRights(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    detachCardFromUser(cardId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/CashdeskServer/DetachCardFromUser?";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDetachCardFromUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDetachCardFromUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDetachCardFromUser(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ColumnTooltipClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    columnTooltip(conumnName: string | null): Observable<string | null> {
        let url_ = this.baseUrl + "/api/ColumnTooltip/ColumnTooltip?";
        if (conumnName === undefined)
            throw new Error("The parameter 'conumnName' must be defined.");
        else
            url_ += "conumnName=" + encodeURIComponent("" + conumnName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processColumnTooltip(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processColumnTooltip(response_);
                } catch (e) {
                    return <Observable<string | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string | null>><any>Observable.throw(response_);
        });
    }

    protected processColumnTooltip(response: HttpResponse<Blob>): Observable<string | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string | null>(<any>null);
    }
}

@Injectable()
export class DayTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: DayType | null): Observable<DayType | null> {
        let url_ = this.baseUrl + "/api/DayTypes/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<DayType | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayType | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<DayType | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayType.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DayType | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/DayTypes/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: DayType | null): Observable<number> {
        let url_ = this.baseUrl + "/api/DayTypes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: DayTypesSelectRequest | null): Observable<DayTypesSelectResponce | null> {
        let url_ = this.baseUrl + "/api/DayTypes/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<DayTypesSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayTypesSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<DayTypesSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayTypesSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DayTypesSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<DayTypeView | null> {
        let url_ = this.baseUrl + "/api/DayTypes/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<DayTypeView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayTypeView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<DayTypeView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayTypeView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DayTypeView | null>(<any>null);
    }
}

@Injectable()
export class DiscountOperationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    addDiscountToCard(time: Date, discountTypeId: number, from: Date, to: Date, uid: string | null, administratorId: number, cashdeskId: number, comment: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/DiscountOperation/AddDiscountToCard?";
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (discountTypeId === undefined || discountTypeId === null)
            throw new Error("The parameter 'discountTypeId' must be defined and cannot be null.");
        else
            url_ += "discountTypeId=" + encodeURIComponent("" + discountTypeId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        if (uid === undefined)
            throw new Error("The parameter 'uid' must be defined.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        if (administratorId === undefined || administratorId === null)
            throw new Error("The parameter 'administratorId' must be defined and cannot be null.");
        else
            url_ += "administratorId=" + encodeURIComponent("" + administratorId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else
            url_ += "comment=" + encodeURIComponent("" + comment) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAddDiscountToCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processAddDiscountToCard(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddDiscountToCard(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    deleteDiscountFromCard(time: Date, discountId: number, cardId: number, administratorId: number, cashdeskId: number, comment: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/DiscountOperation/DeleteDiscountFromCard?";
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent(time ? "" + time.toJSON() : "") + "&"; 
        if (discountId === undefined || discountId === null)
            throw new Error("The parameter 'discountId' must be defined and cannot be null.");
        else
            url_ += "discountId=" + encodeURIComponent("" + discountId) + "&"; 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (administratorId === undefined || administratorId === null)
            throw new Error("The parameter 'administratorId' must be defined and cannot be null.");
        else
            url_ += "administratorId=" + encodeURIComponent("" + administratorId) + "&"; 
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (comment === undefined)
            throw new Error("The parameter 'comment' must be defined.");
        else
            url_ += "comment=" + encodeURIComponent("" + comment) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteDiscountFromCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteDiscountFromCard(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteDiscountFromCard(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DiscountTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getGoodTypes(discountTypeId: number, canWrite: boolean): Observable<DiscountTypeToGoodTypeEntry[] | null> {
        let url_ = this.baseUrl + "/api/DiscountTypes/GetGoodTypes?";
        if (discountTypeId === undefined || discountTypeId === null)
            throw new Error("The parameter 'discountTypeId' must be defined and cannot be null.");
        else
            url_ += "discountTypeId=" + encodeURIComponent("" + discountTypeId) + "&"; 
        if (canWrite === undefined || canWrite === null)
            throw new Error("The parameter 'canWrite' must be defined and cannot be null.");
        else
            url_ += "canWrite=" + encodeURIComponent("" + canWrite) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetGoodTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetGoodTypes(response_);
                } catch (e) {
                    return <Observable<DiscountTypeToGoodTypeEntry[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DiscountTypeToGoodTypeEntry[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetGoodTypes(response: HttpResponse<Blob>): Observable<DiscountTypeToGoodTypeEntry[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DiscountTypeToGoodTypeEntry.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DiscountTypeToGoodTypeEntry[] | null>(<any>null);
    }

    setGoodTypeAmount(discountTypeId: number, goodTypeId: number, amount: number): Observable<number> {
        let url_ = this.baseUrl + "/api/DiscountTypes/SetGoodTypeAmount?";
        if (discountTypeId === undefined || discountTypeId === null)
            throw new Error("The parameter 'discountTypeId' must be defined and cannot be null.");
        else
            url_ += "discountTypeId=" + encodeURIComponent("" + discountTypeId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSetGoodTypeAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetGoodTypeAmount(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processSetGoodTypeAmount(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    deleteGoodTypeAmount(discountTypeId: number, goodTypeId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/DiscountTypes/DeleteGoodTypeAmount?";
        if (discountTypeId === undefined || discountTypeId === null)
            throw new Error("The parameter 'discountTypeId' must be defined and cannot be null.");
        else
            url_ += "discountTypeId=" + encodeURIComponent("" + discountTypeId) + "&"; 
        if (goodTypeId === undefined || goodTypeId === null)
            throw new Error("The parameter 'goodTypeId' must be defined and cannot be null.");
        else
            url_ += "goodTypeId=" + encodeURIComponent("" + goodTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteGoodTypeAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteGoodTypeAmount(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDeleteGoodTypeAmount(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    insert(entity: DiscountType | null): Observable<DiscountType | null> {
        let url_ = this.baseUrl + "/api/DiscountTypes/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<DiscountType | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DiscountType | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<DiscountType | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiscountType.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DiscountType | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/DiscountTypes/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: DiscountType | null): Observable<number> {
        let url_ = this.baseUrl + "/api/DiscountTypes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: DiscountTypesSelectRequest | null): Observable<DiscountTypesSelectResponce | null> {
        let url_ = this.baseUrl + "/api/DiscountTypes/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<DiscountTypesSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DiscountTypesSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<DiscountTypesSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiscountTypesSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DiscountTypesSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<DiscountTypeView | null> {
        let url_ = this.baseUrl + "/api/DiscountTypes/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<DiscountTypeView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<DiscountTypeView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<DiscountTypeView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiscountTypeView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DiscountTypeView | null>(<any>null);
    }
}

@Injectable()
export class GoodTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: GoodType | null): Observable<GoodType | null> {
        let url_ = this.baseUrl + "/api/GoodTypes/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<GoodType | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodType | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<GoodType | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodType.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodType | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/GoodTypes/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: GoodType | null): Observable<number> {
        let url_ = this.baseUrl + "/api/GoodTypes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: GoodTypesSelectRequest | null): Observable<GoodTypesSelectResponce | null> {
        let url_ = this.baseUrl + "/api/GoodTypes/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<GoodTypesSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypesSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<GoodTypesSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodTypesSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypesSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<GoodTypeView | null> {
        let url_ = this.baseUrl + "/api/GoodTypes/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<GoodTypeView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<GoodTypeView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodTypeView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeView | null>(<any>null);
    }
}

@Injectable()
export class GoodTypeTreesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: GoodTypeTree | null): Observable<GoodTypeTree | null> {
        let url_ = this.baseUrl + "/api/GoodTypeTrees/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<GoodTypeTree | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeTree | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<GoodTypeTree | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodTypeTree.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeTree | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/GoodTypeTrees/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: GoodTypeTree | null): Observable<number> {
        let url_ = this.baseUrl + "/api/GoodTypeTrees/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: GoodTypeTreesSelectRequest | null): Observable<GoodTypeTreesSelectResponce | null> {
        let url_ = this.baseUrl + "/api/GoodTypeTrees/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<GoodTypeTreesSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeTreesSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<GoodTypeTreesSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodTypeTreesSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeTreesSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<GoodTypeTreeView | null> {
        let url_ = this.baseUrl + "/api/GoodTypeTrees/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<GoodTypeTreeView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GoodTypeTreeView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<GoodTypeTreeView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GoodTypeTreeView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GoodTypeTreeView | null>(<any>null);
    }
}

@Injectable()
export class HardwareControllerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getSettings(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerSettingsResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/GetSettings?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetSettings(response_);
                } catch (e) {
                    return <Observable<HardwareControllerSettingsResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerSettingsResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetSettings(response: HttpResponse<Blob>): Observable<HardwareControllerSettingsResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerSettingsResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerSettingsResponce | null>(<any>null);
    }

    getTariff(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerTariffResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/GetTariff?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetTariff(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTariff(response_);
                } catch (e) {
                    return <Observable<HardwareControllerTariffResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerTariffResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTariff(response: HttpResponse<Blob>): Observable<HardwareControllerTariffResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerTariffResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerTariffResponce | null>(<any>null);
    }

    uploadGeneralLog(hash: string | null, request: string | null, wrapStrings: boolean): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Hardware/UploadGeneralLog?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUploadGeneralLog(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUploadGeneralLog(response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUploadGeneralLog(response: HttpResponse<Blob>): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.body, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    uploadPassLog(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerLogResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/UploadPassLog?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUploadPassLog(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUploadPassLog(response_);
                } catch (e) {
                    return <Observable<HardwareControllerLogResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerLogResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processUploadPassLog(response: HttpResponse<Blob>): Observable<HardwareControllerLogResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerLogResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerLogResponce | null>(<any>null);
    }

    uploadTransactionLog(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerLogResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/UploadTransactionLog?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUploadTransactionLog(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUploadTransactionLog(response_);
                } catch (e) {
                    return <Observable<HardwareControllerLogResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerLogResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processUploadTransactionLog(response: HttpResponse<Blob>): Observable<HardwareControllerLogResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerLogResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerLogResponce | null>(<any>null);
    }

    validatePass(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerValidatePassResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/ValidatePass?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processValidatePass(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processValidatePass(response_);
                } catch (e) {
                    return <Observable<HardwareControllerValidatePassResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerValidatePassResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processValidatePass(response: HttpResponse<Blob>): Observable<HardwareControllerValidatePassResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerValidatePassResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerValidatePassResponce | null>(<any>null);
    }

    getFirmware(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerFirmwareResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/GetFirmware?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFirmware(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetFirmware(response_);
                } catch (e) {
                    return <Observable<HardwareControllerFirmwareResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerFirmwareResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFirmware(response: HttpResponse<Blob>): Observable<HardwareControllerFirmwareResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerFirmwareResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerFirmwareResponce | null>(<any>null);
    }

    getFirmware2(hash: string | null, request: string | null, wrapStrings: boolean): Observable<HardwareControllerFirmwareResponce | null> {
        let url_ = this.baseUrl + "/api/Hardware/GetFirmware?";
        if (hash === undefined)
            throw new Error("The parameter 'hash' must be defined.");
        else
            url_ += "hash=" + encodeURIComponent("" + hash) + "&"; 
        if (request === undefined)
            throw new Error("The parameter 'request' must be defined.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        if (wrapStrings === undefined || wrapStrings === null)
            throw new Error("The parameter 'wrapStrings' must be defined and cannot be null.");
        else
            url_ += "wrapStrings=" + encodeURIComponent("" + wrapStrings) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetFirmware2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetFirmware2(response_);
                } catch (e) {
                    return <Observable<HardwareControllerFirmwareResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<HardwareControllerFirmwareResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFirmware2(response: HttpResponse<Blob>): Observable<HardwareControllerFirmwareResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HardwareControllerFirmwareResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HardwareControllerFirmwareResponce | null>(<any>null);
    }
}

@Injectable()
export class InstallationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: Installation | null): Observable<Installation | null> {
        let url_ = this.baseUrl + "/api/Installations/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Installation | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Installation | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Installation | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Installation.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Installation | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Installations/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Installation | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Installations/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: InstallationsSelectRequest | null): Observable<InstallationsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Installations/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<InstallationsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<InstallationsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<InstallationView | null> {
        let url_ = this.baseUrl + "/api/Installations/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<InstallationView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<InstallationView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationView | null>(<any>null);
    }
}

@Injectable()
export class InstallationUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: InstallationUser | null): Observable<InstallationUser | null> {
        let url_ = this.baseUrl + "/api/InstallationUsers/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<InstallationUser | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationUser | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<InstallationUser | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationUser.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationUser | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/InstallationUsers/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: InstallationUser | null): Observable<number> {
        let url_ = this.baseUrl + "/api/InstallationUsers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: InstallationUsersSelectRequest | null): Observable<InstallationUsersSelectResponce | null> {
        let url_ = this.baseUrl + "/api/InstallationUsers/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<InstallationUsersSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationUsersSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<InstallationUsersSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationUsersSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationUsersSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<InstallationUserView | null> {
        let url_ = this.baseUrl + "/api/InstallationUsers/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<InstallationUserView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstallationUserView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<InstallationUserView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InstallationUserView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InstallationUserView | null>(<any>null);
    }
}

@Injectable()
export class MobileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    confirmOrder(confirmOrderRequest: ConfirmOrderRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Mobile/ConfirmOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confirmOrderRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processConfirmOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processConfirmOrder(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processConfirmOrder(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getCities(request: GetCitiesRequest | null): Observable<GetCitiesResponce | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetCities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetCities(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetCities(response_);
                } catch (e) {
                    return <Observable<GetCitiesResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCitiesResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCities(response: HttpResponse<Blob>): Observable<GetCitiesResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCitiesResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetCitiesResponce | null>(<any>null);
    }

    getInstallations(request: GetInstallationsRequest | null): Observable<GetInstallationsResponce | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetInstallations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallations(response_);
                } catch (e) {
                    return <Observable<GetInstallationsResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetInstallationsResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallations(response: HttpResponse<Blob>): Observable<GetInstallationsResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInstallationsResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetInstallationsResponce | null>(<any>null);
    }

    registerClient(deviceId: string | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Mobile/RegisterClient?";
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRegisterClient(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterClient(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processRegisterClient(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getClientInfo(clientId: number, deviceId: string | null): Observable<GetClientInfoResponce | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetClientInfo?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined and cannot be null.");
        else
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetClientInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetClientInfo(response_);
                } catch (e) {
                    return <Observable<GetClientInfoResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetClientInfoResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetClientInfo(response: HttpResponse<Blob>): Observable<GetClientInfoResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetClientInfoResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetClientInfoResponce | null>(<any>null);
    }

    getServicies(request: GetServiciesRequest | null): Observable<GetServiciesResponce | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetServicies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetServicies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServicies(response_);
                } catch (e) {
                    return <Observable<GetServiciesResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetServiciesResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServicies(response: HttpResponse<Blob>): Observable<GetServiciesResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetServiciesResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetServiciesResponce | null>(<any>null);
    }

    getServiceByQr(qr: string | null): Observable<ServiceInfo | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetServiceByQr?";
        if (qr === undefined)
            throw new Error("The parameter 'qr' must be defined.");
        else
            url_ += "qr=" + encodeURIComponent("" + qr) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServiceByQr(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServiceByQr(response_);
                } catch (e) {
                    return <Observable<ServiceInfo | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceInfo | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServiceByQr(response: HttpResponse<Blob>): Observable<ServiceInfo | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceInfo.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceInfo | null>(<any>null);
    }

    getServiceOperations(clientId: number, deviceId: string | null, from: Date, to: Date): Observable<ServiceOperation[] | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetServiceOperations?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined and cannot be null.");
        else
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServiceOperations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServiceOperations(response_);
                } catch (e) {
                    return <Observable<ServiceOperation[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceOperation[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServiceOperations(response: HttpResponse<Blob>): Observable<ServiceOperation[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ServiceOperation.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceOperation[] | null>(<any>null);
    }

    getBuyOperations(clientId: number, deviceId: string | null, from: Date, to: Date): Observable<BuyOperation[] | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetBuyOperations?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined and cannot be null.");
        else
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetBuyOperations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetBuyOperations(response_);
                } catch (e) {
                    return <Observable<BuyOperation[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<BuyOperation[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetBuyOperations(response: HttpResponse<Blob>): Observable<BuyOperation[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BuyOperation.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BuyOperation[] | null>(<any>null);
    }

    getServiceTickets(serviceId: number): Observable<ServiceTicket[] | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetServiceTickets?";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined and cannot be null.");
        else
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServiceTickets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServiceTickets(response_);
                } catch (e) {
                    return <Observable<ServiceTicket[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTicket[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServiceTickets(response: HttpResponse<Blob>): Observable<ServiceTicket[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ServiceTicket.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTicket[] | null>(<any>null);
    }

    getServiceImage(serviceId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetServiceImage?";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined and cannot be null.");
        else
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServiceImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServiceImage(response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServiceImage(response: HttpResponse<Blob>): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.body, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getInstallationImage(installationId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetInstallationImage?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallationImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallationImage(response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallationImage(response: HttpResponse<Blob>): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.body, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getAccountTypes(installationId: number): Observable<AccountType[] | null> {
        let url_ = this.baseUrl + "/api/Mobile/GetAccountTypes?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAccountTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAccountTypes(response_);
                } catch (e) {
                    return <Observable<AccountType[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountType[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAccountTypes(response: HttpResponse<Blob>): Observable<AccountType[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AccountType.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AccountType[] | null>(<any>null);
    }
}

@Injectable()
export class MobileServicePointClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Used to register new mobile service point
     * @installationId P:Jade.Api.Database.Installation.Id. Available installations can be optained with T:Jade.Api.Controllers.InstallationsController
     * @guid Mobile guid
     * @name Human readable controller name
     * @return Registered service point
     */
    register(installationId: number, guid: string | null, name: string | null): Observable<ServicePoint | null> {
        let url_ = this.baseUrl + "/api/MobileServicePoint/Register?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        if (guid === undefined)
            throw new Error("The parameter 'guid' must be defined.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&"; 
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegister(response_);
                } catch (e) {
                    return <Observable<ServicePoint | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePoint | null>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponse<Blob>): Observable<ServicePoint | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicePoint.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePoint | null>(<any>null);
    }

    /**
     * Get mobile point
     * @pointId P:Jade.Api.Database.ServicePoint.Id
     */
    select(pointId: number): Observable<ServicePoint | null> {
        let url_ = this.baseUrl + "/api/MobileServicePoint/Select?";
        if (pointId === undefined || pointId === null)
            throw new Error("The parameter 'pointId' must be defined and cannot be null.");
        else
            url_ += "pointId=" + encodeURIComponent("" + pointId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<ServicePoint | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePoint | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<ServicePoint | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicePoint.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePoint | null>(<any>null);
    }

    /**
     * Get servicies for mobile service point
     * @id P:Jade.Api.Database.ServicePoint.Id
     * @return List of available T:Jade.Api.Database.Service for provided . List would be empty for unknown
     */
    getServicies(id: number): Observable<Service[] | null> {
        let url_ = this.baseUrl + "/api/MobileServicePoint/GetServicies?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServicies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServicies(response_);
                } catch (e) {
                    return <Observable<Service[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Service[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServicies(response: HttpResponse<Blob>): Observable<Service[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Service.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Service[] | null>(<any>null);
    }

    /**
     * Validates pass
     * @servicePointId P:Jade.Api.Database.ServicePoint.Id
     * @serviceId P:Jade.Api.Database.Service.Id
     * @direction Direction of pass
     * @code Barcode or RFID card UID
     * @return T:Jade.Api.Models.MobileServicePoint.ValidatePassResponce
     */
    validatePass(servicePointId: number, serviceId: number, direction: Direction, code: string | null, passTime: Date, cardType: CardType): Observable<ValidatePassResponce | null> {
        let url_ = this.baseUrl + "/api/MobileServicePoint/ValidatePass?";
        if (servicePointId === undefined || servicePointId === null)
            throw new Error("The parameter 'servicePointId' must be defined and cannot be null.");
        else
            url_ += "servicePointId=" + encodeURIComponent("" + servicePointId) + "&"; 
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined and cannot be null.");
        else
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (passTime === undefined || passTime === null)
            throw new Error("The parameter 'passTime' must be defined and cannot be null.");
        else
            url_ += "passTime=" + encodeURIComponent(passTime ? "" + passTime.toJSON() : "") + "&"; 
        if (cardType === undefined || cardType === null)
            throw new Error("The parameter 'cardType' must be defined and cannot be null.");
        else
            url_ += "cardType=" + encodeURIComponent("" + cardType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processValidatePass(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processValidatePass(response_);
                } catch (e) {
                    return <Observable<ValidatePassResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ValidatePassResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processValidatePass(response: HttpResponse<Blob>): Observable<ValidatePassResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValidatePassResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ValidatePassResponce | null>(<any>null);
    }
}

@Injectable()
export class OrganizationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getOrganizationsByInstallation(installationId: number): Observable<Organization[] | null> {
        let url_ = this.baseUrl + "/api/Organizations/GetOrganizationsByInstallation?";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined and cannot be null.");
        else
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationsByInstallation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetOrganizationsByInstallation(response_);
                } catch (e) {
                    return <Observable<Organization[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organization[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationsByInstallation(response: HttpResponse<Blob>): Observable<Organization[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Organization.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Organization[] | null>(<any>null);
    }

    insert(entity: Organization | null): Observable<Organization | null> {
        let url_ = this.baseUrl + "/api/Organizations/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Organization | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organization | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Organization | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organization.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Organization | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Organizations/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Organization | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Organizations/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: OrganizationsSelectRequest | null): Observable<OrganizationsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Organizations/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<OrganizationsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<OrganizationsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<OrganizationView | null> {
        let url_ = this.baseUrl + "/api/Organizations/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<OrganizationView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<OrganizationView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationView | null>(<any>null);
    }
}

@Injectable()
export class OrganizationUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: OrganizationUser | null): Observable<OrganizationUser | null> {
        let url_ = this.baseUrl + "/api/OrganizationUsers/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<OrganizationUser | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUser | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<OrganizationUser | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUser.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUser | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/OrganizationUsers/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: OrganizationUser | null): Observable<number> {
        let url_ = this.baseUrl + "/api/OrganizationUsers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: OrganizationUsersSelectRequest | null): Observable<OrganizationUsersSelectResponce | null> {
        let url_ = this.baseUrl + "/api/OrganizationUsers/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<OrganizationUsersSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUsersSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<OrganizationUsersSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUsersSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUsersSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<OrganizationUserView | null> {
        let url_ = this.baseUrl + "/api/OrganizationUsers/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<OrganizationUserView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUserView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<OrganizationUserView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUserView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUserView | null>(<any>null);
    }
}

@Injectable()
export class ProcessingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    cashdeskAcquiringDrivers(): Observable<CashdeskAcquiringDriver[] | null> {
        let url_ = this.baseUrl + "/api/Processings/CashdeskAcquiringDrivers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCashdeskAcquiringDrivers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCashdeskAcquiringDrivers(response_);
                } catch (e) {
                    return <Observable<CashdeskAcquiringDriver[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskAcquiringDriver[] | null>><any>Observable.throw(response_);
        });
    }

    protected processCashdeskAcquiringDrivers(response: HttpResponse<Blob>): Observable<CashdeskAcquiringDriver[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskAcquiringDriver.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskAcquiringDriver[] | null>(<any>null);
    }

    insert(entity: Processing | null): Observable<Processing | null> {
        let url_ = this.baseUrl + "/api/Processings/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Processing | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Processing | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Processing | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Processing.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Processing | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Processings/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Processing | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Processings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: ProcessingsSelectRequest | null): Observable<ProcessingsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Processings/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<ProcessingsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProcessingsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<ProcessingsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProcessingsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProcessingsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<ProcessingView | null> {
        let url_ = this.baseUrl + "/api/Processings/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<ProcessingView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProcessingView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<ProcessingView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProcessingView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProcessingView | null>(<any>null);
    }
}

@Injectable()
export class ReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    cashdeskTotalsReport(cashdeskId: number, from: Date, to: Date): Observable<CashdeskTotalsReportLine[] | null> {
        let url_ = this.baseUrl + "/api/Reports/CashdeskTotalsReport?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCashdeskTotalsReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCashdeskTotalsReport(response_);
                } catch (e) {
                    return <Observable<CashdeskTotalsReportLine[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskTotalsReportLine[] | null>><any>Observable.throw(response_);
        });
    }

    protected processCashdeskTotalsReport(response: HttpResponse<Blob>): Observable<CashdeskTotalsReportLine[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskTotalsReportLine.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskTotalsReportLine[] | null>(<any>null);
    }

    cashdeskPayTotalsXReport(cashdeskId: number, from: Date, to: Date): Observable<CashdeskPayTotalsXReportLine[] | null> {
        let url_ = this.baseUrl + "/api/Reports/CashdeskPayTotalsXReport?";
        if (cashdeskId === undefined || cashdeskId === null)
            throw new Error("The parameter 'cashdeskId' must be defined and cannot be null.");
        else
            url_ += "cashdeskId=" + encodeURIComponent("" + cashdeskId) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCashdeskPayTotalsXReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processCashdeskPayTotalsXReport(response_);
                } catch (e) {
                    return <Observable<CashdeskPayTotalsXReportLine[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashdeskPayTotalsXReportLine[] | null>><any>Observable.throw(response_);
        });
    }

    protected processCashdeskPayTotalsXReport(response: HttpResponse<Blob>): Observable<CashdeskPayTotalsXReportLine[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashdeskPayTotalsXReportLine.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CashdeskPayTotalsXReportLine[] | null>(<any>null);
    }

    getInstallationTotals(from: Date, to: Date, organizationId: number | null, returnsOnly: boolean, showReturns: boolean, showAdministrative: boolean): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Reports/GetInstallationTotals?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        if (organizationId !== undefined)
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (returnsOnly === null)
            throw new Error("The parameter 'returnsOnly' cannot be null.");
        else if (returnsOnly !== undefined)
            url_ += "returnsOnly=" + encodeURIComponent("" + returnsOnly) + "&"; 
        if (showReturns === null)
            throw new Error("The parameter 'showReturns' cannot be null.");
        else if (showReturns !== undefined)
            url_ += "showReturns=" + encodeURIComponent("" + showReturns) + "&"; 
        if (showAdministrative === null)
            throw new Error("The parameter 'showAdministrative' cannot be null.");
        else if (showAdministrative !== undefined)
            url_ += "showAdministrative=" + encodeURIComponent("" + showAdministrative) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInstallationTotals(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetInstallationTotals(response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInstallationTotals(response: HttpResponse<Blob>): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.body, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class ServicePointsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    setService(servicePointId: number, serviceId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/ServicePoints/SetService?";
        if (servicePointId === undefined || servicePointId === null)
            throw new Error("The parameter 'servicePointId' must be defined and cannot be null.");
        else
            url_ += "servicePointId=" + encodeURIComponent("" + servicePointId) + "&"; 
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined and cannot be null.");
        else
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetService(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetService(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processSetService(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    removeService(servicePointId: number, serviceId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/ServicePoints/RemoveService?";
        if (servicePointId === undefined || servicePointId === null)
            throw new Error("The parameter 'servicePointId' must be defined and cannot be null.");
        else
            url_ += "servicePointId=" + encodeURIComponent("" + servicePointId) + "&"; 
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined and cannot be null.");
        else
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRemoveService(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRemoveService(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processRemoveService(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getServices(servicePointId: number): Observable<ServicePointServiceBound[] | null> {
        let url_ = this.baseUrl + "/api/ServicePoints/GetServices?";
        if (servicePointId === undefined || servicePointId === null)
            throw new Error("The parameter 'servicePointId' must be defined and cannot be null.");
        else
            url_ += "servicePointId=" + encodeURIComponent("" + servicePointId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServices(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetServices(response_);
                } catch (e) {
                    return <Observable<ServicePointServiceBound[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePointServiceBound[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetServices(response: HttpResponse<Blob>): Observable<ServicePointServiceBound[] | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ServicePointServiceBound.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePointServiceBound[] | null>(<any>null);
    }

    insert(entity: ServicePoint | null): Observable<ServicePoint | null> {
        let url_ = this.baseUrl + "/api/ServicePoints/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<ServicePoint | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePoint | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<ServicePoint | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicePoint.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePoint | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/ServicePoints/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: ServicePoint | null): Observable<number> {
        let url_ = this.baseUrl + "/api/ServicePoints/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: ServicePointsSelectRequest | null): Observable<ServicePointsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/ServicePoints/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<ServicePointsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePointsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<ServicePointsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicePointsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePointsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<ServicePointView | null> {
        let url_ = this.baseUrl + "/api/ServicePoints/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<ServicePointView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicePointView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<ServicePointView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicePointView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicePointView | null>(<any>null);
    }
}

@Injectable()
export class ServicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    selectTariffs(request: ServiceTariffRequest | null): Observable<ServiceTariffResponce | null> {
        let url_ = this.baseUrl + "/api/Services/SelectTariffs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelectTariffs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelectTariffs(response_);
                } catch (e) {
                    return <Observable<ServiceTariffResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariffResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelectTariffs(response: HttpResponse<Blob>): Observable<ServiceTariffResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariffResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariffResponce | null>(<any>null);
    }

    getTariff(tariffId: number, canWrite: boolean): Observable<ServiceTariffView | null> {
        let url_ = this.baseUrl + "/api/Services/GetTariff?";
        if (tariffId === undefined || tariffId === null)
            throw new Error("The parameter 'tariffId' must be defined and cannot be null.");
        else
            url_ += "tariffId=" + encodeURIComponent("" + tariffId) + "&"; 
        if (canWrite === undefined || canWrite === null)
            throw new Error("The parameter 'canWrite' must be defined and cannot be null.");
        else
            url_ += "canWrite=" + encodeURIComponent("" + canWrite) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTariff(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTariff(response_);
                } catch (e) {
                    return <Observable<ServiceTariffView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariffView | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTariff(response: HttpResponse<Blob>): Observable<ServiceTariffView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariffView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariffView | null>(<any>null);
    }

    insertOrReplaceTariff(tariff: ServiceTariff | null): Observable<ServiceTariff | null> {
        let url_ = this.baseUrl + "/api/Services/InsertOrReplaceTariff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tariff);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processInsertOrReplaceTariff(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsertOrReplaceTariff(response_);
                } catch (e) {
                    return <Observable<ServiceTariff | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariff | null>><any>Observable.throw(response_);
        });
    }

    protected processInsertOrReplaceTariff(response: HttpResponse<Blob>): Observable<ServiceTariff | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariff.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariff | null>(<any>null);
    }

    deleteServiceTariff(tariff: ServiceTariff | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Services/DeleteServiceTariff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tariff);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteServiceTariff(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteServiceTariff(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDeleteServiceTariff(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    insert(entity: Service | null): Observable<Service | null> {
        let url_ = this.baseUrl + "/api/Services/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Service | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Service | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Service | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Service.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Service | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Services/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Service | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Services/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: ServicesSelectRequest | null): Observable<ServicesSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Services/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<ServicesSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServicesSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<ServicesSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServicesSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServicesSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<ServiceView | null> {
        let url_ = this.baseUrl + "/api/Services/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<ServiceView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<ServiceView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceView | null>(<any>null);
    }
}

@Injectable()
export class ServiceTariffModifiersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: ServiceTariffModifier | null): Observable<ServiceTariffModifier | null> {
        let url_ = this.baseUrl + "/api/ServiceTariffModifiers/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<ServiceTariffModifier | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariffModifier | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<ServiceTariffModifier | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariffModifier.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariffModifier | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/ServiceTariffModifiers/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: ServiceTariffModifier | null): Observable<number> {
        let url_ = this.baseUrl + "/api/ServiceTariffModifiers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: ServiceTariffModifiersSelectRequest | null): Observable<ServiceTariffModifiersSelectResponce | null> {
        let url_ = this.baseUrl + "/api/ServiceTariffModifiers/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<ServiceTariffModifiersSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariffModifiersSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<ServiceTariffModifiersSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariffModifiersSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariffModifiersSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<ServiceTariffModifierView | null> {
        let url_ = this.baseUrl + "/api/ServiceTariffModifiers/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<ServiceTariffModifierView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceTariffModifierView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<ServiceTariffModifierView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceTariffModifierView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceTariffModifierView | null>(<any>null);
    }
}

@Injectable()
export class SystemManagementClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getSpicies(): Observable<Spicies | null> {
        let url_ = this.baseUrl + "/api/SystemManagement/GetSpicies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetSpicies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetSpicies(response_);
                } catch (e) {
                    return <Observable<Spicies | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Spicies | null>><any>Observable.throw(response_);
        });
    }

    protected processGetSpicies(response: HttpResponse<Blob>): Observable<Spicies | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Spicies.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Spicies | null>(<any>null);
    }

    setSpicies(spicies: Spicies | null): Observable<void> {
        let url_ = this.baseUrl + "/api/SystemManagement/SetSpicies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(spicies);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetSpicies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSetSpicies(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetSpicies(response: HttpResponse<Blob>): Observable<void> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TariffsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: Tariff | null): Observable<Tariff | null> {
        let url_ = this.baseUrl + "/api/Tariffs/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<Tariff | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tariff | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<Tariff | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tariff.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Tariff | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Tariffs/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: Tariff | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Tariffs/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: TariffsSelectRequest | null): Observable<TariffsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Tariffs/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<TariffsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TariffsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<TariffsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TariffsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TariffsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<TariffView | null> {
        let url_ = this.baseUrl + "/api/Tariffs/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<TariffView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TariffView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<TariffView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TariffView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TariffView | null>(<any>null);
    }
}

@Injectable()
export class TimeLimitationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: TimeLimitation | null): Observable<TimeLimitation | null> {
        let url_ = this.baseUrl + "/api/TimeLimitations/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<TimeLimitation | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TimeLimitation | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<TimeLimitation | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TimeLimitation.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TimeLimitation | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/TimeLimitations/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: TimeLimitation | null): Observable<number> {
        let url_ = this.baseUrl + "/api/TimeLimitations/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: TimeLimitationsSelectRequest | null): Observable<TimeLimitationsSelectResponce | null> {
        let url_ = this.baseUrl + "/api/TimeLimitations/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<TimeLimitationsSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TimeLimitationsSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<TimeLimitationsSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TimeLimitationsSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TimeLimitationsSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<TimeLimitationView | null> {
        let url_ = this.baseUrl + "/api/TimeLimitations/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<TimeLimitationView | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TimeLimitationView | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<TimeLimitationView | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TimeLimitationView.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TimeLimitationView | null>(<any>null);
    }
}

@Injectable()
export class UsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    insert(entity: UserData | null): Observable<UserData | null> {
        let url_ = this.baseUrl + "/api/Users/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsert(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processInsert(response_);
                } catch (e) {
                    return <Observable<UserData | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserData | null>><any>Observable.throw(response_);
        });
    }

    protected processInsert(response: HttpResponse<Blob>): Observable<UserData | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserData.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserData | null>(<any>null);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Users/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    update(entity: UserData | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Users/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponse<Blob>): Observable<number> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    select(request: UsersSelectRequest | null): Observable<UsersSelectResponce | null> {
        let url_ = this.baseUrl + "/api/Users/Select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect(response_);
                } catch (e) {
                    return <Observable<UsersSelectResponce | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersSelectResponce | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect(response: HttpResponse<Blob>): Observable<UsersSelectResponce | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersSelectResponce.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UsersSelectResponce | null>(<any>null);
    }

    select2(id: number): Observable<UserData | null> {
        let url_ = this.baseUrl + "/api/Users/Select/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSelect2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processSelect2(response_);
                } catch (e) {
                    return <Observable<UserData | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserData | null>><any>Observable.throw(response_);
        });
    }

    protected processSelect2(response: HttpResponse<Blob>): Observable<UserData | null> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserData.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserData | null>(<any>null);
    }
}

/** Responce of T:Jade.Api.Controllers.AboutController */
export class AboutResponce implements IAboutResponce {
    /** API Version */
    readonly generalVersion?: string | undefined;
    /** API version */
    readonly apiVersion?: string | undefined;
    /** Application version */
    readonly applicationVersion?: string | undefined;
    /** Application edition */
    readonly applicationEdition?: string | undefined;
    /** True if Enterprise Edition */
    readonly enterprise: boolean;

    constructor(data?: IAboutResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).generalVersion = data["generalVersion"];
            (<any>this).apiVersion = data["apiVersion"];
            (<any>this).applicationVersion = data["applicationVersion"];
            (<any>this).applicationEdition = data["applicationEdition"];
            (<any>this).enterprise = data["enterprise"];
        }
    }

    static fromJS(data: any): AboutResponce {
        let result = new AboutResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalVersion"] = this.generalVersion;
        data["apiVersion"] = this.apiVersion;
        data["applicationVersion"] = this.applicationVersion;
        data["applicationEdition"] = this.applicationEdition;
        data["enterprise"] = this.enterprise;
        return data; 
    }
}

/** Responce of T:Jade.Api.Controllers.AboutController */
export interface IAboutResponce {
    /** API Version */
    generalVersion?: string | undefined;
    /** API version */
    apiVersion?: string | undefined;
    /** Application version */
    applicationVersion?: string | undefined;
    /** Application edition */
    applicationEdition?: string | undefined;
    /** True if Enterprise Edition */
    enterprise: boolean;
}

export class LoginRequest implements ILoginRequest {
    phoneOrEmail: string;
    password: string;
    rememberMe: boolean;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneOrEmail = data["phoneOrEmail"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginRequest {
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneOrEmail"] = this.phoneOrEmail;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginRequest {
    phoneOrEmail: string;
    password: string;
    rememberMe: boolean;
}

export class SignInResult implements ISignInResult {
    succeeded: boolean;
    isLockedOut: boolean;
    isNotAllowed: boolean;
    requiresTwoFactor: boolean;

    constructor(data?: ISignInResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.succeeded = data["succeeded"];
            this.isLockedOut = data["isLockedOut"];
            this.isNotAllowed = data["isNotAllowed"];
            this.requiresTwoFactor = data["requiresTwoFactor"];
        }
    }

    static fromJS(data: any): SignInResult {
        let result = new SignInResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["isLockedOut"] = this.isLockedOut;
        data["isNotAllowed"] = this.isNotAllowed;
        data["requiresTwoFactor"] = this.requiresTwoFactor;
        return data; 
    }
}

export interface ISignInResult {
    succeeded: boolean;
    isLockedOut: boolean;
    isNotAllowed: boolean;
    requiresTwoFactor: boolean;
}

export class RegisterRequest implements IRegisterRequest {
    email: string;
    name: string;
    surame: string;
    patronomic?: string | undefined;
    displayName: string;
    password: string;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.name = data["name"];
            this.surame = data["surame"];
            this.patronomic = data["patronomic"];
            this.displayName = data["displayName"];
            this.password = data["password"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["surame"] = this.surame;
        data["patronomic"] = this.patronomic;
        data["displayName"] = this.displayName;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterRequest {
    email: string;
    name: string;
    surame: string;
    patronomic?: string | undefined;
    displayName: string;
    password: string;
    confirmPassword?: string | undefined;
}

export class ResultBaseOfBoolean implements IResultBaseOfBoolean {
    value: boolean;
    errors?: ErrorInfo[] | undefined;

    constructor(data?: IResultBaseOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(ErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultBaseOfBoolean {
        let result = new ResultBaseOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResultBaseOfBoolean {
    value: boolean;
    errors?: ErrorInfo[] | undefined;
}

export class ErrorInfo implements IErrorInfo {
    code?: string | undefined;
    message?: string | undefined;

    constructor(data?: IErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ErrorInfo {
        let result = new ErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface IErrorInfo {
    code?: string | undefined;
    message?: string | undefined;
}

export class GetUserAndCardResponse implements IGetUserAndCardResponse {
    user?: User | undefined;
    card?: Card | undefined;
    installationUser?: InstallationUser | undefined;

    constructor(data?: IGetUserAndCardResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.card = data["card"] ? Card.fromJS(data["card"]) : <any>undefined;
            this.installationUser = data["installationUser"] ? InstallationUser.fromJS(data["installationUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserAndCardResponse {
        let result = new GetUserAndCardResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["installationUser"] = this.installationUser ? this.installationUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetUserAndCardResponse {
    user?: User | undefined;
    card?: Card | undefined;
    installationUser?: InstallationUser | undefined;
}

export class UserData implements IUserData {
    id: number;
    readonly email?: string | undefined;
    readonly emailConfirmed: boolean;
    readonly phoneNumber?: string | undefined;
    readonly phoneNumberConfirmed: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    patronomic?: string | undefined;
    displayName?: string | undefined;
    culture?: string | undefined;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            (<any>this).email = data["email"];
            (<any>this).emailConfirmed = data["emailConfirmed"];
            (<any>this).phoneNumber = data["phoneNumber"];
            (<any>this).phoneNumberConfirmed = data["phoneNumberConfirmed"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.patronomic = data["patronomic"];
            this.displayName = data["displayName"];
            this.culture = data["culture"];
        }
    }

    static fromJS(data: any): UserData {
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["patronomic"] = this.patronomic;
        data["displayName"] = this.displayName;
        data["culture"] = this.culture;
        return data; 
    }
}

export interface IUserData {
    id: number;
    email?: string | undefined;
    emailConfirmed: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    patronomic?: string | undefined;
    displayName?: string | undefined;
    culture?: string | undefined;
}

export class User extends UserData implements IUser {
    accessFailedCount: number;
    concurrencyStamp?: string | undefined;
    lockoutEnabled: boolean;
    lockoutEnd?: Date | undefined;
    normalizedEmail?: string | undefined;
    readonly normalizedUserName?: string | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    twoFactorEnabled: boolean;
    readonly userName: string;
    registrationTime: Date;
    mailWarning?: boolean | undefined;
    mailWarningMessage?: string | undefined;

    constructor(data?: IUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.accessFailedCount = data["accessFailedCount"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.lockoutEnabled = data["lockoutEnabled"];
            this.lockoutEnd = data["lockoutEnd"] ? new Date(data["lockoutEnd"].toString()) : <any>undefined;
            this.normalizedEmail = data["normalizedEmail"];
            (<any>this).normalizedUserName = data["normalizedUserName"];
            this.passwordHash = data["passwordHash"];
            this.securityStamp = data["securityStamp"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            (<any>this).userName = data["userName"];
            this.registrationTime = data["registrationTime"] ? new Date(data["registrationTime"].toString()) : <any>undefined;
            this.mailWarning = data["mailWarning"];
            this.mailWarningMessage = data["mailWarningMessage"];
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessFailedCount"] = this.accessFailedCount;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["normalizedEmail"] = this.normalizedEmail;
        data["normalizedUserName"] = this.normalizedUserName;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["userName"] = this.userName;
        data["registrationTime"] = this.registrationTime ? this.registrationTime.toISOString() : <any>undefined;
        data["mailWarning"] = this.mailWarning;
        data["mailWarningMessage"] = this.mailWarningMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IUser extends IUserData {
    accessFailedCount: number;
    concurrencyStamp?: string | undefined;
    lockoutEnabled: boolean;
    lockoutEnd?: Date | undefined;
    normalizedEmail?: string | undefined;
    normalizedUserName?: string | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    twoFactorEnabled: boolean;
    userName: string;
    registrationTime: Date;
    mailWarning?: boolean | undefined;
    mailWarningMessage?: string | undefined;
}

export class Card implements ICard {
    id: number;
    code: string;
    userId?: number | undefined;
    boardNumber?: string | undefined;
    installationId: number;
    state: number;
    goodTypeId?: number | undefined;
    isDiscount: boolean;
    sellDate?: Date | undefined;

    constructor(data?: ICard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.userId = data["userId"];
            this.boardNumber = data["boardNumber"];
            this.installationId = data["installationId"];
            this.state = data["state"];
            this.goodTypeId = data["goodTypeId"];
            this.isDiscount = data["isDiscount"];
            this.sellDate = data["sellDate"] ? new Date(data["sellDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Card {
        let result = new Card();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["userId"] = this.userId;
        data["boardNumber"] = this.boardNumber;
        data["installationId"] = this.installationId;
        data["state"] = this.state;
        data["goodTypeId"] = this.goodTypeId;
        data["isDiscount"] = this.isDiscount;
        data["sellDate"] = this.sellDate ? this.sellDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICard {
    id: number;
    code: string;
    userId?: number | undefined;
    boardNumber?: string | undefined;
    installationId: number;
    state: number;
    goodTypeId?: number | undefined;
    isDiscount: boolean;
    sellDate?: Date | undefined;
}

export class InstallationUser implements IInstallationUser {
    id: number;
    userId: number;
    installationId: number;
    isInstallationOwner: boolean;
    isInstallationAdministrator: boolean;
    isCashier: boolean;
    cashierCode?: string | undefined;
    isHeadCashier: boolean;

    constructor(data?: IInstallationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.installationId = data["installationId"];
            this.isInstallationOwner = data["isInstallationOwner"];
            this.isInstallationAdministrator = data["isInstallationAdministrator"];
            this.isCashier = data["isCashier"];
            this.cashierCode = data["cashierCode"];
            this.isHeadCashier = data["isHeadCashier"];
        }
    }

    static fromJS(data: any): InstallationUser {
        let result = new InstallationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["installationId"] = this.installationId;
        data["isInstallationOwner"] = this.isInstallationOwner;
        data["isInstallationAdministrator"] = this.isInstallationAdministrator;
        data["isCashier"] = this.isCashier;
        data["cashierCode"] = this.cashierCode;
        data["isHeadCashier"] = this.isHeadCashier;
        return data; 
    }
}

export interface IInstallationUser {
    id: number;
    userId: number;
    installationId: number;
    isInstallationOwner: boolean;
    isInstallationAdministrator: boolean;
    isCashier: boolean;
    cashierCode?: string | undefined;
    isHeadCashier: boolean;
}

export class ChangeEmailRequest implements IChangeEmailRequest {
    email?: string | undefined;

    constructor(data?: IChangeEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): ChangeEmailRequest {
        let result = new ChangeEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IChangeEmailRequest {
    email?: string | undefined;
}

export class LocaleProfileResponce implements ILocaleProfileResponce {
    language?: string | undefined;
    currency?: string | undefined;

    constructor(data?: ILocaleProfileResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"];
            this.currency = data["currency"];
        }
    }

    static fromJS(data: any): LocaleProfileResponce {
        let result = new LocaleProfileResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface ILocaleProfileResponce {
    language?: string | undefined;
    currency?: string | undefined;
}

export class IdentityDataResopnce implements IIdentityDataResopnce {
    readonly hasPassword: boolean;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    readonly phoneNumberConfirmed: boolean;
    readonly emailConfirmed: boolean;
    logins?: ExternalLoginInfo[] | undefined;

    constructor(data?: IIdentityDataResopnce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).hasPassword = data["hasPassword"];
            this.phoneNumber = data["phoneNumber"];
            this.email = data["email"];
            (<any>this).phoneNumberConfirmed = data["phoneNumberConfirmed"];
            (<any>this).emailConfirmed = data["emailConfirmed"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [];
                for (let item of data["logins"])
                    this.logins.push(ExternalLoginInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityDataResopnce {
        let result = new IdentityDataResopnce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasPassword"] = this.hasPassword;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["emailConfirmed"] = this.emailConfirmed;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIdentityDataResopnce {
    hasPassword: boolean;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    phoneNumberConfirmed: boolean;
    emailConfirmed: boolean;
    logins?: ExternalLoginInfo[] | undefined;
}

export class ExternalLoginInfo implements IExternalLoginInfo {
    userLogin?: UserLoginInfo | undefined;
    provider?: ProviderDescription | undefined;

    constructor(data?: IExternalLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userLogin = data["userLogin"] ? UserLoginInfo.fromJS(data["userLogin"]) : <any>undefined;
            this.provider = data["provider"] ? ProviderDescription.fromJS(data["provider"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExternalLoginInfo {
        let result = new ExternalLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userLogin"] = this.userLogin ? this.userLogin.toJSON() : <any>undefined;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IExternalLoginInfo {
    userLogin?: UserLoginInfo | undefined;
    provider?: ProviderDescription | undefined;
}

export class UserLoginInfo implements IUserLoginInfo {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.providerDisplayName = data["providerDisplayName"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        return data; 
    }
}

export interface IUserLoginInfo {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
}

export class ProviderDescription implements IProviderDescription {
    authenticationScheme?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IProviderDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticationScheme = data["authenticationScheme"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProviderDescription {
        let result = new ProviderDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationScheme"] = this.authenticationScheme;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProviderDescription {
    authenticationScheme?: string | undefined;
    displayName?: string | undefined;
}

export class SetPhoneRequest implements ISetPhoneRequest {
    phoneNumber: string;
    confirm: boolean;

    constructor(data?: ISetPhoneRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
            this.confirm = data["confirm"];
        }
    }

    static fromJS(data: any): SetPhoneRequest {
        let result = new SetPhoneRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["confirm"] = this.confirm;
        return data; 
    }
}

export interface ISetPhoneRequest {
    phoneNumber: string;
    confirm: boolean;
}

export class ConfirmPhoneRequest implements IConfirmPhoneRequest {
    code: string;
    phoneNumber: string;

    constructor(data?: IConfirmPhoneRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): ConfirmPhoneRequest {
        let result = new ConfirmPhoneRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IConfirmPhoneRequest {
    code: string;
    phoneNumber: string;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["oldPassword"];
            this.newPassword = data["newPassword"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IChangePasswordRequest {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export class CreatePasswordRequest implements ICreatePasswordRequest {
    newPassword: string;
    confirmPassword: string;

    constructor(data?: ICreatePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newPassword = data["newPassword"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): CreatePasswordRequest {
        let result = new CreatePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface ICreatePasswordRequest {
    newPassword: string;
    confirmPassword: string;
}

export class AccountProcessingTransaction implements IAccountProcessingTransaction {
    transaction: AccountProcessing = new AccountProcessing();
    account: Right = new Right();
    requireCardUpdate: boolean;

    constructor(data?: IAccountProcessingTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transaction = data["transaction"] ? AccountProcessing.fromJS(data["transaction"]) : new AccountProcessing();
            this.account = data["account"] ? Right.fromJS(data["account"]) : new Right();
            this.requireCardUpdate = data["requireCardUpdate"];
        }
    }

    static fromJS(data: any): AccountProcessingTransaction {
        let result = new AccountProcessingTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["requireCardUpdate"] = this.requireCardUpdate;
        return data; 
    }
}

export interface IAccountProcessingTransaction {
    transaction: AccountProcessing;
    account: Right;
    requireCardUpdate: boolean;
}

export class AccountProcessing implements IAccountProcessing {
    id: number;
    rightId: number;
    amount: number;
    originalAmount: number;
    hold: boolean;
    holdTime: Date;
    processTime?: Date | undefined;
    cancel: boolean;
    cancelTime?: Date | undefined;
    cancelComment?: string | undefined;

    constructor(data?: IAccountProcessing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rightId = data["rightId"];
            this.amount = data["amount"];
            this.originalAmount = data["originalAmount"];
            this.hold = data["hold"];
            this.holdTime = data["holdTime"] ? new Date(data["holdTime"].toString()) : <any>undefined;
            this.processTime = data["processTime"] ? new Date(data["processTime"].toString()) : <any>undefined;
            this.cancel = data["cancel"];
            this.cancelTime = data["cancelTime"] ? new Date(data["cancelTime"].toString()) : <any>undefined;
            this.cancelComment = data["cancelComment"];
        }
    }

    static fromJS(data: any): AccountProcessing {
        let result = new AccountProcessing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rightId"] = this.rightId;
        data["amount"] = this.amount;
        data["originalAmount"] = this.originalAmount;
        data["hold"] = this.hold;
        data["holdTime"] = this.holdTime ? this.holdTime.toISOString() : <any>undefined;
        data["processTime"] = this.processTime ? this.processTime.toISOString() : <any>undefined;
        data["cancel"] = this.cancel;
        data["cancelTime"] = this.cancelTime ? this.cancelTime.toISOString() : <any>undefined;
        data["cancelComment"] = this.cancelComment;
        return data; 
    }
}

export interface IAccountProcessing {
    id: number;
    rightId: number;
    amount: number;
    originalAmount: number;
    hold: boolean;
    holdTime: Date;
    processTime?: Date | undefined;
    cancel: boolean;
    cancelTime?: Date | undefined;
    cancelComment?: string | undefined;
}

export class Right implements IRight {
    id: number;
    goodTypeId: number;
    cardId: number;
    amount: number;
    from: Date;
    to?: Date | undefined;
    lastUse?: Date | undefined;
    userId?: number | undefined;
    confirmed: boolean;

    constructor(data?: IRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.goodTypeId = data["goodTypeId"];
            this.cardId = data["cardId"];
            this.amount = data["amount"];
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.lastUse = data["lastUse"] ? new Date(data["lastUse"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.confirmed = data["confirmed"];
        }
    }

    static fromJS(data: any): Right {
        let result = new Right();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["goodTypeId"] = this.goodTypeId;
        data["cardId"] = this.cardId;
        data["amount"] = this.amount;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["lastUse"] = this.lastUse ? this.lastUse.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["confirmed"] = this.confirmed;
        return data; 
    }
}

export interface IRight {
    id: number;
    goodTypeId: number;
    cardId: number;
    amount: number;
    from: Date;
    to?: Date | undefined;
    lastUse?: Date | undefined;
    userId?: number | undefined;
    confirmed: boolean;
}

export class CalendarDay implements ICalendarDay {
    calendarId: number;
    date: Date;
    dayTypeId: number;

    constructor(data?: ICalendarDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calendarId = data["calendarId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dayTypeId = data["dayTypeId"];
        }
    }

    static fromJS(data: any): CalendarDay {
        let result = new CalendarDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarId"] = this.calendarId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dayTypeId"] = this.dayTypeId;
        return data; 
    }
}

export interface ICalendarDay {
    calendarId: number;
    date: Date;
    dayTypeId: number;
}

export class Calendar implements ICalendar {
    id: number;
    name: string;
    installationId: number;
    defaultDayTypeId: number;

    constructor(data?: ICalendar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.installationId = data["installationId"];
            this.defaultDayTypeId = data["defaultDayTypeId"];
        }
    }

    static fromJS(data: any): Calendar {
        let result = new Calendar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        data["defaultDayTypeId"] = this.defaultDayTypeId;
        return data; 
    }
}

export interface ICalendar {
    id: number;
    name: string;
    installationId: number;
    defaultDayTypeId: number;
}

export class SelectRequestBaseOfInstallationFilter implements ISelectRequestBaseOfInstallationFilter {
    filter: InstallationFilter = new InstallationFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfInstallationFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? InstallationFilter.fromJS(data["filter"]) : new InstallationFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfInstallationFilter {
        let result = new SelectRequestBaseOfInstallationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfInstallationFilter {
    filter: InstallationFilter;
    page: Paginator;
}

export class CalendarsSelectRequest extends SelectRequestBaseOfInstallationFilter implements ICalendarsSelectRequest {

    constructor(data?: ICalendarsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CalendarsSelectRequest {
        let result = new CalendarsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICalendarsSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class FilterBase implements IFilterBase {
    search?: string | undefined;
    id?: number | undefined;

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.search = data["search"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FilterBase {
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["search"] = this.search;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFilterBase {
    search?: string | undefined;
    id?: number | undefined;
}

export class CanWriteFilter extends FilterBase implements ICanWriteFilter {
    canWrite: boolean;

    constructor(data?: ICanWriteFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
        }
    }

    static fromJS(data: any): CanWriteFilter {
        let result = new CanWriteFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        super.toJSON(data);
        return data; 
    }
}

export interface ICanWriteFilter extends IFilterBase {
    canWrite: boolean;
}

/** Base filter entyties by */
export class InstallationFilter extends CanWriteFilter implements IInstallationFilter {
    installationId: number;

    constructor(data?: IInstallationFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.installationId = data["installationId"];
        }
    }

    static fromJS(data: any): InstallationFilter {
        let result = new InstallationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationId"] = this.installationId;
        super.toJSON(data);
        return data; 
    }
}

/** Base filter entyties by */
export interface IInstallationFilter extends ICanWriteFilter {
    installationId: number;
}

export class Paginator implements IPaginator {
    skip: number;
    take: number;

    constructor(data?: IPaginator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skip = data["skip"];
            this.take = data["take"];
        }
    }

    static fromJS(data: any): Paginator {
        let result = new Paginator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPaginator {
    skip: number;
    take: number;
}

export class SelectResponceBaseOfCalendarView implements ISelectResponceBaseOfCalendarView {
    data?: CalendarView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfCalendarView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CalendarView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfCalendarView {
        let result = new SelectResponceBaseOfCalendarView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfCalendarView {
    data?: CalendarView[] | undefined;
    total: number;
}

export class CalendarsSelectResponce extends SelectResponceBaseOfCalendarView implements ICalendarsSelectResponce {

    constructor(data?: ICalendarsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CalendarsSelectResponce {
        let result = new CalendarsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICalendarsSelectResponce extends ISelectResponceBaseOfCalendarView {
}

/** Represents T:Jade.Api.Database.Calendar view with referenced entity names */
export class CalendarView extends Calendar implements ICalendarView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** References P:Jade.Api.Database.Installation.CreationTime */
    installationCreationTime: Date;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.Calendar.DefaultDayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Calendar.InstallationId */
    installationName?: string | undefined;

    constructor(data?: ICalendarView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationCreationTime = data["installationCreationTime"] ? new Date(data["installationCreationTime"].toString()) : <any>undefined;
            this.dayTypeName = data["dayTypeName"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): CalendarView {
        let result = new CalendarView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationCreationTime"] = this.installationCreationTime ? this.installationCreationTime.toISOString() : <any>undefined;
        data["dayTypeName"] = this.dayTypeName;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Calendar view with referenced entity names */
export interface ICalendarView extends ICalendar {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** References P:Jade.Api.Database.Installation.CreationTime */
    installationCreationTime: Date;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.Calendar.DefaultDayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Calendar.InstallationId */
    installationName?: string | undefined;
}

export enum CashdeskPrinterDriver {
    Virtual = 0, 
    Atol = 1, 
}

export class CashdeskPrinterModel implements ICashdeskPrinterModel {
    cashdeskPrinterDriver: CashdeskPrinterDriver;
    id: number;
    name?: string | undefined;

    constructor(data?: ICashdeskPrinterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashdeskPrinterDriver = data["cashdeskPrinterDriver"];
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CashdeskPrinterModel {
        let result = new CashdeskPrinterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashdeskPrinterDriver"] = this.cashdeskPrinterDriver;
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICashdeskPrinterModel {
    cashdeskPrinterDriver: CashdeskPrinterDriver;
    id: number;
    name?: string | undefined;
}

export class CashdeskPrinter implements ICashdeskPrinter {
    id: number;
    printerNumber?: string | undefined;
    inn?: string | undefined;
    registrationNumber?: string | undefined;
    baudRate?: number | undefined;
    connection?: CashdeskPrinterConnectionType | undefined;
    driver: CashdeskPrinterDriver;
    errorChance?: number | undefined;
    model?: number | undefined;
    portNumber?: number | undefined;
    cashdeskId: number;
    name: string;
    organizationId?: number | undefined;
    printChecks: boolean;
    printSlips: boolean;
    printTickets: boolean;
    active: boolean;

    constructor(data?: ICashdeskPrinter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.printerNumber = data["printerNumber"];
            this.inn = data["inn"];
            this.registrationNumber = data["registrationNumber"];
            this.baudRate = data["baudRate"];
            this.connection = data["connection"];
            this.driver = data["driver"];
            this.errorChance = data["errorChance"];
            this.model = data["model"];
            this.portNumber = data["portNumber"];
            this.cashdeskId = data["cashdeskId"];
            this.name = data["name"];
            this.organizationId = data["organizationId"];
            this.printChecks = data["printChecks"];
            this.printSlips = data["printSlips"];
            this.printTickets = data["printTickets"];
            this.active = data["active"];
        }
    }

    static fromJS(data: any): CashdeskPrinter {
        let result = new CashdeskPrinter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["printerNumber"] = this.printerNumber;
        data["inn"] = this.inn;
        data["registrationNumber"] = this.registrationNumber;
        data["baudRate"] = this.baudRate;
        data["connection"] = this.connection;
        data["driver"] = this.driver;
        data["errorChance"] = this.errorChance;
        data["model"] = this.model;
        data["portNumber"] = this.portNumber;
        data["cashdeskId"] = this.cashdeskId;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["printChecks"] = this.printChecks;
        data["printSlips"] = this.printSlips;
        data["printTickets"] = this.printTickets;
        data["active"] = this.active;
        return data; 
    }
}

export interface ICashdeskPrinter {
    id: number;
    printerNumber?: string | undefined;
    inn?: string | undefined;
    registrationNumber?: string | undefined;
    baudRate?: number | undefined;
    connection?: CashdeskPrinterConnectionType | undefined;
    driver: CashdeskPrinterDriver;
    errorChance?: number | undefined;
    model?: number | undefined;
    portNumber?: number | undefined;
    cashdeskId: number;
    name: string;
    organizationId?: number | undefined;
    printChecks: boolean;
    printSlips: boolean;
    printTickets: boolean;
    active: boolean;
}

export enum CashdeskPrinterConnectionType {
    Rs232 = 0, 
}

export class SelectRequestBaseOfCashdeskPrinterFilter implements ISelectRequestBaseOfCashdeskPrinterFilter {
    filter: CashdeskPrinterFilter = new CashdeskPrinterFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfCashdeskPrinterFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? CashdeskPrinterFilter.fromJS(data["filter"]) : new CashdeskPrinterFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfCashdeskPrinterFilter {
        let result = new SelectRequestBaseOfCashdeskPrinterFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfCashdeskPrinterFilter {
    filter: CashdeskPrinterFilter;
    page: Paginator;
}

export class CashdeskPrintersSelectRequest extends SelectRequestBaseOfCashdeskPrinterFilter implements ICashdeskPrintersSelectRequest {

    constructor(data?: ICashdeskPrintersSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CashdeskPrintersSelectRequest {
        let result = new CashdeskPrintersSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdeskPrintersSelectRequest extends ISelectRequestBaseOfCashdeskPrinterFilter {
}

export class CashdeskPrinterFilter extends CanWriteFilter implements ICashdeskPrinterFilter {
    cashdeskId: number;

    constructor(data?: ICashdeskPrinterFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cashdeskId = data["cashdeskId"];
        }
    }

    static fromJS(data: any): CashdeskPrinterFilter {
        let result = new CashdeskPrinterFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashdeskId"] = this.cashdeskId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdeskPrinterFilter extends ICanWriteFilter {
    cashdeskId: number;
}

export class SelectResponceBaseOfCashdeskPrinterView implements ISelectResponceBaseOfCashdeskPrinterView {
    data?: CashdeskPrinterView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfCashdeskPrinterView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CashdeskPrinterView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfCashdeskPrinterView {
        let result = new SelectResponceBaseOfCashdeskPrinterView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfCashdeskPrinterView {
    data?: CashdeskPrinterView[] | undefined;
    total: number;
}

export class CashdeskPrintersSelectResponce extends SelectResponceBaseOfCashdeskPrinterView implements ICashdeskPrintersSelectResponce {

    constructor(data?: ICashdeskPrintersSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CashdeskPrintersSelectResponce {
        let result = new CashdeskPrintersSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdeskPrintersSelectResponce extends ISelectResponceBaseOfCashdeskPrinterView {
}

/** Represents T:Jade.Api.Database.CashdeskPrinter view with referenced entity names */
export class CashdeskPrinterView extends CashdeskPrinter implements ICashdeskPrinterView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.CashdeskPrinter.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.Cashdesk.Name of T:Jade.Api.Database.Cashdesk referenced by P:Jade.Api.Database.CashdeskPrinter.CashdeskId */
    cashdeskName?: string | undefined;

    constructor(data?: ICashdeskPrinterView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.organizationName = data["organizationName"];
            this.cashdeskName = data["cashdeskName"];
        }
    }

    static fromJS(data: any): CashdeskPrinterView {
        let result = new CashdeskPrinterView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["organizationName"] = this.organizationName;
        data["cashdeskName"] = this.cashdeskName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.CashdeskPrinter view with referenced entity names */
export interface ICashdeskPrinterView extends ICashdeskPrinter {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.CashdeskPrinter.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.Cashdesk.Name of T:Jade.Api.Database.Cashdesk referenced by P:Jade.Api.Database.CashdeskPrinter.CashdeskId */
    cashdeskName?: string | undefined;
}

export class CashdeskToGoodType implements ICashdeskToGoodType {
    goodTypeId: number;
    cashdeskId: number;
    hotKeyCode?: number | undefined;
    frecuentlyUse: boolean;

    constructor(data?: ICashdeskToGoodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.goodTypeId = data["goodTypeId"];
            this.cashdeskId = data["cashdeskId"];
            this.hotKeyCode = data["hotKeyCode"];
            this.frecuentlyUse = data["frecuentlyUse"];
        }
    }

    static fromJS(data: any): CashdeskToGoodType {
        let result = new CashdeskToGoodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodTypeId"] = this.goodTypeId;
        data["cashdeskId"] = this.cashdeskId;
        data["hotKeyCode"] = this.hotKeyCode;
        data["frecuentlyUse"] = this.frecuentlyUse;
        return data; 
    }
}

export interface ICashdeskToGoodType {
    goodTypeId: number;
    cashdeskId: number;
    hotKeyCode?: number | undefined;
    frecuentlyUse: boolean;
}

/** Represents T:Jade.Api.Database.CashdeskToGoodType view with referenced entity names */
export class CashdeskToGoodTypeView extends CashdeskToGoodType implements ICashdeskToGoodTypeView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** This field is not present in database. It is used for editor purpose only. */
    isSelected: boolean;
    /** References P:Jade.Api.Database.GoodType.GoodTypeTreeId */
    goodTypeTreeId?: number | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.CashdeskToGoodType.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Cashdesk.Name of T:Jade.Api.Database.Cashdesk referenced by P:Jade.Api.Database.CashdeskToGoodType.CashdeskId */
    cashdeskName?: string | undefined;

    constructor(data?: ICashdeskToGoodTypeView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.isSelected = data["isSelected"];
            this.goodTypeTreeId = data["goodTypeTreeId"];
            this.goodTypeName = data["goodTypeName"];
            this.cashdeskName = data["cashdeskName"];
        }
    }

    static fromJS(data: any): CashdeskToGoodTypeView {
        let result = new CashdeskToGoodTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["isSelected"] = this.isSelected;
        data["goodTypeTreeId"] = this.goodTypeTreeId;
        data["goodTypeName"] = this.goodTypeName;
        data["cashdeskName"] = this.cashdeskName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.CashdeskToGoodType view with referenced entity names */
export interface ICashdeskToGoodTypeView extends ICashdeskToGoodType {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** This field is not present in database. It is used for editor purpose only. */
    isSelected: boolean;
    /** References P:Jade.Api.Database.GoodType.GoodTypeTreeId */
    goodTypeTreeId?: number | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.CashdeskToGoodType.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Cashdesk.Name of T:Jade.Api.Database.Cashdesk referenced by P:Jade.Api.Database.CashdeskToGoodType.CashdeskId */
    cashdeskName?: string | undefined;
}

export class Cashdesk implements ICashdesk {
    id: number;
    name: string;
    installationId: number;
    rfidReaderPort?: number | undefined;
    hasPosDisplay?: boolean | undefined;
    posDisplayPortNumber: number;
    posDisplayBaudRate: number;
    posDisplayCharacterSet: number;

    constructor(data?: ICashdesk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.installationId = data["installationId"];
            this.rfidReaderPort = data["rfidReaderPort"];
            this.hasPosDisplay = data["hasPosDisplay"];
            this.posDisplayPortNumber = data["posDisplayPortNumber"];
            this.posDisplayBaudRate = data["posDisplayBaudRate"];
            this.posDisplayCharacterSet = data["posDisplayCharacterSet"];
        }
    }

    static fromJS(data: any): Cashdesk {
        let result = new Cashdesk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        data["rfidReaderPort"] = this.rfidReaderPort;
        data["hasPosDisplay"] = this.hasPosDisplay;
        data["posDisplayPortNumber"] = this.posDisplayPortNumber;
        data["posDisplayBaudRate"] = this.posDisplayBaudRate;
        data["posDisplayCharacterSet"] = this.posDisplayCharacterSet;
        return data; 
    }
}

export interface ICashdesk {
    id: number;
    name: string;
    installationId: number;
    rfidReaderPort?: number | undefined;
    hasPosDisplay?: boolean | undefined;
    posDisplayPortNumber: number;
    posDisplayBaudRate: number;
    posDisplayCharacterSet: number;
}

export class CashdesksSelectRequest extends SelectRequestBaseOfInstallationFilter implements ICashdesksSelectRequest {

    constructor(data?: ICashdesksSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CashdesksSelectRequest {
        let result = new CashdesksSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdesksSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfCashdeskView implements ISelectResponceBaseOfCashdeskView {
    data?: CashdeskView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfCashdeskView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CashdeskView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfCashdeskView {
        let result = new SelectResponceBaseOfCashdeskView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfCashdeskView {
    data?: CashdeskView[] | undefined;
    total: number;
}

export class CashdesksSelectResponce extends SelectResponceBaseOfCashdeskView implements ICashdesksSelectResponce {

    constructor(data?: ICashdesksSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CashdesksSelectResponce {
        let result = new CashdesksSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdesksSelectResponce extends ISelectResponceBaseOfCashdeskView {
}

/** Represents T:Jade.Api.Database.Cashdesk view with referenced entity names */
export class CashdeskView extends Cashdesk implements ICashdeskView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Cashdesk.InstallationId */
    installationName?: string | undefined;

    constructor(data?: ICashdeskView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): CashdeskView {
        let result = new CashdeskView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Cashdesk view with referenced entity names */
export interface ICashdeskView extends ICashdesk {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Cashdesk.InstallationId */
    installationName?: string | undefined;
}

export class GoodType implements IGoodType {
    id: number;
    organizationId: number;
    name: string;
    kind: GoodTypeKind;
    vat: Vat;
    requireCount: boolean;
    isWritable: boolean;
    isIncremental: boolean;
    goodTypeTreeId?: number | undefined;
    basePrice?: number | undefined;
    defaultAmount?: number | undefined;
    timeLimitationId?: number | undefined;
    order: number;
    multiplier: number;
    allowReturn: boolean;
    delay: number;
    checkLastPass: boolean;
    revaluationType: RevaluationType;
    cardEmissionType: CardEmissionType;
    hidden: boolean;
    softOfflineDefault: boolean;
    lightIndication?: number | undefined;
    voiceIndication?: number | undefined;

    constructor(data?: IGoodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationId = data["organizationId"];
            this.name = data["name"];
            this.kind = data["kind"];
            this.vat = data["vat"];
            this.requireCount = data["requireCount"];
            this.isWritable = data["isWritable"];
            this.isIncremental = data["isIncremental"];
            this.goodTypeTreeId = data["goodTypeTreeId"];
            this.basePrice = data["basePrice"];
            this.defaultAmount = data["defaultAmount"];
            this.timeLimitationId = data["timeLimitationId"];
            this.order = data["order"];
            this.multiplier = data["multiplier"];
            this.allowReturn = data["allowReturn"];
            this.delay = data["delay"];
            this.checkLastPass = data["checkLastPass"];
            this.revaluationType = data["revaluationType"];
            this.cardEmissionType = data["cardEmissionType"];
            this.hidden = data["hidden"];
            this.softOfflineDefault = data["softOfflineDefault"];
            this.lightIndication = data["lightIndication"];
            this.voiceIndication = data["voiceIndication"];
        }
    }

    static fromJS(data: any): GoodType {
        let result = new GoodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["name"] = this.name;
        data["kind"] = this.kind;
        data["vat"] = this.vat;
        data["requireCount"] = this.requireCount;
        data["isWritable"] = this.isWritable;
        data["isIncremental"] = this.isIncremental;
        data["goodTypeTreeId"] = this.goodTypeTreeId;
        data["basePrice"] = this.basePrice;
        data["defaultAmount"] = this.defaultAmount;
        data["timeLimitationId"] = this.timeLimitationId;
        data["order"] = this.order;
        data["multiplier"] = this.multiplier;
        data["allowReturn"] = this.allowReturn;
        data["delay"] = this.delay;
        data["checkLastPass"] = this.checkLastPass;
        data["revaluationType"] = this.revaluationType;
        data["cardEmissionType"] = this.cardEmissionType;
        data["hidden"] = this.hidden;
        data["softOfflineDefault"] = this.softOfflineDefault;
        data["lightIndication"] = this.lightIndication;
        data["voiceIndication"] = this.voiceIndication;
        return data; 
    }
}

export interface IGoodType {
    id: number;
    organizationId: number;
    name: string;
    kind: GoodTypeKind;
    vat: Vat;
    requireCount: boolean;
    isWritable: boolean;
    isIncremental: boolean;
    goodTypeTreeId?: number | undefined;
    basePrice?: number | undefined;
    defaultAmount?: number | undefined;
    timeLimitationId?: number | undefined;
    order: number;
    multiplier: number;
    allowReturn: boolean;
    delay: number;
    checkLastPass: boolean;
    revaluationType: RevaluationType;
    cardEmissionType: CardEmissionType;
    hidden: boolean;
    softOfflineDefault: boolean;
    lightIndication?: number | undefined;
    voiceIndication?: number | undefined;
}

export class GoodTypeWithQrDeny extends GoodType implements IGoodTypeWithQrDeny {
    denyQrCode: boolean;

    constructor(data?: IGoodTypeWithQrDeny) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.denyQrCode = data["denyQrCode"];
        }
    }

    static fromJS(data: any): GoodTypeWithQrDeny {
        let result = new GoodTypeWithQrDeny();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denyQrCode"] = this.denyQrCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypeWithQrDeny extends IGoodType {
    denyQrCode: boolean;
}

export enum GoodTypeKind {
    Card = 0, 
    Account = 1, 
    Ticket = 2, 
    Stuff = 3, 
}

export enum Vat {
    Vat1 = 0, 
    Vat2 = 1, 
    Vat3 = 2, 
    Vat4 = 3, 
    Vat5 = 4, 
    Vat6 = 5, 
}

export enum RevaluationType {
    None = 0, 
    ByAmount = 1, 
    ByTime = 2, 
}

export enum CardEmissionType {
    RfidWright = 0, 
    BarcodeGenerate = 1, 
}

export class GoodHotKey implements IGoodHotKey {
    goodTypeId: number;
    hotKeyCode?: number | undefined;

    constructor(data?: IGoodHotKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.goodTypeId = data["goodTypeId"];
            this.hotKeyCode = data["hotKeyCode"];
        }
    }

    static fromJS(data: any): GoodHotKey {
        let result = new GoodHotKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodTypeId"] = this.goodTypeId;
        data["hotKeyCode"] = this.hotKeyCode;
        return data; 
    }
}

export interface IGoodHotKey {
    goodTypeId: number;
    hotKeyCode?: number | undefined;
}

export class GoodTypeTree implements IGoodTypeTree {
    id: number;
    parentId?: number | undefined;
    name: string;
    installationId: number;

    constructor(data?: IGoodTypeTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.installationId = data["installationId"];
        }
    }

    static fromJS(data: any): GoodTypeTree {
        let result = new GoodTypeTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        return data; 
    }
}

export interface IGoodTypeTree {
    id: number;
    parentId?: number | undefined;
    name: string;
    installationId: number;
}

export class Processing implements IProcessing {
    id: number;
    name: string;
    acquirer?: string | undefined;
    installationId: number;
    isChangeble: boolean;
    paymentType: PaymentType;
    cashdeskAcquiringDriverId?: number | undefined;
    printerCurrencyId: number;
    processingMode: ProcessingMode;
    canReturn: boolean;
    goodTypeId?: number | undefined;

    constructor(data?: IProcessing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.acquirer = data["acquirer"];
            this.installationId = data["installationId"];
            this.isChangeble = data["isChangeble"];
            this.paymentType = data["paymentType"];
            this.cashdeskAcquiringDriverId = data["cashdeskAcquiringDriverId"];
            this.printerCurrencyId = data["printerCurrencyId"];
            this.processingMode = data["processingMode"];
            this.canReturn = data["canReturn"];
            this.goodTypeId = data["goodTypeId"];
        }
    }

    static fromJS(data: any): Processing {
        let result = new Processing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["acquirer"] = this.acquirer;
        data["installationId"] = this.installationId;
        data["isChangeble"] = this.isChangeble;
        data["paymentType"] = this.paymentType;
        data["cashdeskAcquiringDriverId"] = this.cashdeskAcquiringDriverId;
        data["printerCurrencyId"] = this.printerCurrencyId;
        data["processingMode"] = this.processingMode;
        data["canReturn"] = this.canReturn;
        data["goodTypeId"] = this.goodTypeId;
        return data; 
    }
}

export interface IProcessing {
    id: number;
    name: string;
    acquirer?: string | undefined;
    installationId: number;
    isChangeble: boolean;
    paymentType: PaymentType;
    cashdeskAcquiringDriverId?: number | undefined;
    printerCurrencyId: number;
    processingMode: ProcessingMode;
    canReturn: boolean;
    goodTypeId?: number | undefined;
}

/** Payment type */
export enum PaymentType {
    Cash = 0, 
    Noncash = 1, 
    Account = 2, 
    CashdeskAcquiring = 3, 
}

export enum ProcessingMode {
    Fiscal = 0, 
    Discount = 1, 
}

export class CardWithInstallation implements ICardWithInstallation {
    card?: CardInfoResponse | undefined;
    installationName?: string | undefined;
    installationId: number;

    constructor(data?: ICardWithInstallation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.card = data["card"] ? CardInfoResponse.fromJS(data["card"]) : <any>undefined;
            this.installationName = data["installationName"];
            this.installationId = data["installationId"];
        }
    }

    static fromJS(data: any): CardWithInstallation {
        let result = new CardWithInstallation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["installationName"] = this.installationName;
        data["installationId"] = this.installationId;
        return data; 
    }
}

export interface ICardWithInstallation {
    card?: CardInfoResponse | undefined;
    installationName?: string | undefined;
    installationId: number;
}

export class CardInfoResponse implements ICardInfoResponse {
    card?: Card | undefined;
    userData?: UserData | undefined;
    sellDate: Date;
    cardEmissionType?: CardEmissionType | undefined;
    rights?: RightView[] | undefined;
    discounts?: DiscountInfo[] | undefined;

    constructor(data?: ICardInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.card = data["card"] ? Card.fromJS(data["card"]) : <any>undefined;
            this.userData = data["userData"] ? UserData.fromJS(data["userData"]) : <any>undefined;
            this.sellDate = data["sellDate"] ? new Date(data["sellDate"].toString()) : <any>undefined;
            this.cardEmissionType = data["cardEmissionType"];
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(RightView.fromJS(item));
            }
            if (data["discounts"] && data["discounts"].constructor === Array) {
                this.discounts = [];
                for (let item of data["discounts"])
                    this.discounts.push(DiscountInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CardInfoResponse {
        let result = new CardInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["userData"] = this.userData ? this.userData.toJSON() : <any>undefined;
        data["sellDate"] = this.sellDate ? this.sellDate.toISOString() : <any>undefined;
        data["cardEmissionType"] = this.cardEmissionType;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item.toJSON());
        }
        if (this.discounts && this.discounts.constructor === Array) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICardInfoResponse {
    card?: Card | undefined;
    userData?: UserData | undefined;
    sellDate: Date;
    cardEmissionType?: CardEmissionType | undefined;
    rights?: RightView[] | undefined;
    discounts?: DiscountInfo[] | undefined;
}

export class RightView implements IRightView {
    installationId: number;
    right: Right = new Right();
    type: GoodType = new GoodType();
    wasReturned: boolean;

    constructor(data?: IRightView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.installationId = data["installationId"];
            this.right = data["right"] ? Right.fromJS(data["right"]) : new Right();
            this.type = data["type"] ? GoodType.fromJS(data["type"]) : new GoodType();
            this.wasReturned = data["wasReturned"];
        }
    }

    static fromJS(data: any): RightView {
        let result = new RightView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationId"] = this.installationId;
        data["right"] = this.right ? this.right.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["wasReturned"] = this.wasReturned;
        return data; 
    }
}

export interface IRightView {
    installationId: number;
    right: Right;
    type: GoodType;
    wasReturned: boolean;
}

export class DiscountInfo implements IDiscountInfo {
    discount?: Discount | undefined;
    discountType?: DiscountType | undefined;

    constructor(data?: IDiscountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.discount = data["discount"] ? Discount.fromJS(data["discount"]) : <any>undefined;
            this.discountType = data["discountType"] ? DiscountType.fromJS(data["discountType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscountInfo {
        let result = new DiscountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["discountType"] = this.discountType ? this.discountType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDiscountInfo {
    discount?: Discount | undefined;
    discountType?: DiscountType | undefined;
}

export class Discount implements IDiscount {
    id: number;
    discountTypeId: number;
    discountRuleId?: number | undefined;
    cardId?: number | undefined;
    from: Date;
    to: Date;
    userId?: number | undefined;

    constructor(data?: IDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.discountTypeId = data["discountTypeId"];
            this.discountRuleId = data["discountRuleId"];
            this.cardId = data["cardId"];
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): Discount {
        let result = new Discount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["discountTypeId"] = this.discountTypeId;
        data["discountRuleId"] = this.discountRuleId;
        data["cardId"] = this.cardId;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IDiscount {
    id: number;
    discountTypeId: number;
    discountRuleId?: number | undefined;
    cardId?: number | undefined;
    from: Date;
    to: Date;
    userId?: number | undefined;
}

export class DiscountType implements IDiscountType {
    id: number;
    isPercent: boolean;
    amount: number;
    summable: boolean;
    installationId: number;
    name: string;

    constructor(data?: IDiscountType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isPercent = data["isPercent"];
            this.amount = data["amount"];
            this.summable = data["summable"];
            this.installationId = data["installationId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): DiscountType {
        let result = new DiscountType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isPercent"] = this.isPercent;
        data["amount"] = this.amount;
        data["summable"] = this.summable;
        data["installationId"] = this.installationId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDiscountType {
    id: number;
    isPercent: boolean;
    amount: number;
    summable: boolean;
    installationId: number;
    name: string;
}

export class GetCardsRequest implements IGetCardsRequest {
    cardIds?: number[] | undefined;
    accountProcessingIds?: number[] | undefined;

    constructor(data?: IGetCardsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cardIds"] && data["cardIds"].constructor === Array) {
                this.cardIds = [];
                for (let item of data["cardIds"])
                    this.cardIds.push(item);
            }
            if (data["accountProcessingIds"] && data["accountProcessingIds"].constructor === Array) {
                this.accountProcessingIds = [];
                for (let item of data["accountProcessingIds"])
                    this.accountProcessingIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetCardsRequest {
        let result = new GetCardsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cardIds && this.cardIds.constructor === Array) {
            data["cardIds"] = [];
            for (let item of this.cardIds)
                data["cardIds"].push(item);
        }
        if (this.accountProcessingIds && this.accountProcessingIds.constructor === Array) {
            data["accountProcessingIds"] = [];
            for (let item of this.accountProcessingIds)
                data["accountProcessingIds"].push(item);
        }
        return data; 
    }
}

export interface IGetCardsRequest {
    cardIds?: number[] | undefined;
    accountProcessingIds?: number[] | undefined;
}

export class GetCardsResponce implements IGetCardsResponce {
    cards?: Card[] | undefined;
    accountProcessingCards?: { [key: string] : Card; } | undefined;

    constructor(data?: IGetCardsResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cards"] && data["cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["cards"])
                    this.cards.push(Card.fromJS(item));
            }
            if (data["accountProcessingCards"]) {
                this.accountProcessingCards = {};
                for (let key in data["accountProcessingCards"]) {
                    if (data["accountProcessingCards"].hasOwnProperty(key))
                        this.accountProcessingCards[key] = data["accountProcessingCards"][key] ? Card.fromJS(data["accountProcessingCards"][key]) : new Card();
                }
            }
        }
    }

    static fromJS(data: any): GetCardsResponce {
        let result = new GetCardsResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cards && this.cards.constructor === Array) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        if (this.accountProcessingCards) {
            data["accountProcessingCards"] = {};
            for (let key in this.accountProcessingCards) {
                if (this.accountProcessingCards.hasOwnProperty(key))
                    data["accountProcessingCards"][key] = this.accountProcessingCards[key];
            }
        }
        return data; 
    }
}

export interface IGetCardsResponce {
    cards?: Card[] | undefined;
    accountProcessingCards?: { [key: string] : Card; } | undefined;
}

export class CurrentUserInfoResponce implements ICurrentUserInfoResponce {
    user?: UserData | undefined;
    installationRights?: InstallationUserView | undefined;
    organizationsRights?: OrganizationUserView[] | undefined;

    constructor(data?: ICurrentUserInfoResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserData.fromJS(data["user"]) : <any>undefined;
            this.installationRights = data["installationRights"] ? InstallationUserView.fromJS(data["installationRights"]) : <any>undefined;
            if (data["organizationsRights"] && data["organizationsRights"].constructor === Array) {
                this.organizationsRights = [];
                for (let item of data["organizationsRights"])
                    this.organizationsRights.push(OrganizationUserView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrentUserInfoResponce {
        let result = new CurrentUserInfoResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["installationRights"] = this.installationRights ? this.installationRights.toJSON() : <any>undefined;
        if (this.organizationsRights && this.organizationsRights.constructor === Array) {
            data["organizationsRights"] = [];
            for (let item of this.organizationsRights)
                data["organizationsRights"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICurrentUserInfoResponce {
    user?: UserData | undefined;
    installationRights?: InstallationUserView | undefined;
    organizationsRights?: OrganizationUserView[] | undefined;
}

/** Represents T:Jade.Api.Database.InstallationUser view with referenced entity names */
export class InstallationUserView extends InstallationUser implements IInstallationUserView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.InstallationUser.InstallationId */
    installationName?: string | undefined;
    /** Represents P:Jade.Api.Database.UserData.Name of T:Jade.Api.Database.User referenced by P:Jade.Api.Database.InstallationUser.UserId */
    userName?: string | undefined;

    constructor(data?: IInstallationUserView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): InstallationUserView {
        let result = new InstallationUserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        data["userName"] = this.userName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.InstallationUser view with referenced entity names */
export interface IInstallationUserView extends IInstallationUser {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.InstallationUser.InstallationId */
    installationName?: string | undefined;
    /** Represents P:Jade.Api.Database.UserData.Name of T:Jade.Api.Database.User referenced by P:Jade.Api.Database.InstallationUser.UserId */
    userName?: string | undefined;
}

export class OrganizationUser implements IOrganizationUser {
    id: number;
    organizationId: number;
    userId: number;
    isOrganizationOwner: boolean;

    constructor(data?: IOrganizationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationId = data["organizationId"];
            this.userId = data["userId"];
            this.isOrganizationOwner = data["isOrganizationOwner"];
        }
    }

    static fromJS(data: any): OrganizationUser {
        let result = new OrganizationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["isOrganizationOwner"] = this.isOrganizationOwner;
        return data; 
    }
}

export interface IOrganizationUser {
    id: number;
    organizationId: number;
    userId: number;
    isOrganizationOwner: boolean;
}

/** Represents T:Jade.Api.Database.OrganizationUser view with referenced entity names */
export class OrganizationUserView extends OrganizationUser implements IOrganizationUserView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.UserData.Name of T:Jade.Api.Database.User referenced by P:Jade.Api.Database.OrganizationUser.UserId */
    userName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.OrganizationUser.OrganizationId */
    organizationName?: string | undefined;

    constructor(data?: IOrganizationUserView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.userName = data["userName"];
            this.organizationName = data["organizationName"];
        }
    }

    static fromJS(data: any): OrganizationUserView {
        let result = new OrganizationUserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["userName"] = this.userName;
        data["organizationName"] = this.organizationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.OrganizationUser view with referenced entity names */
export interface IOrganizationUserView extends IOrganizationUser {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.UserData.Name of T:Jade.Api.Database.User referenced by P:Jade.Api.Database.OrganizationUser.UserId */
    userName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.OrganizationUser.OrganizationId */
    organizationName?: string | undefined;
}

export class GetReturnInfoResponse implements IGetReturnInfoResponse {
    data?: ReturnInfo[] | undefined;

    constructor(data?: IGetReturnInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ReturnInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReturnInfoResponse {
        let result = new GetReturnInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReturnInfoResponse {
    data?: ReturnInfo[] | undefined;
}

export class ReturnInfo implements IReturnInfo {
    cashdesk?: Cashdesk | undefined;
    checkEntry?: FullCheckEntryData | undefined;
    right?: Right | undefined;
    check?: Check | undefined;
    goodType?: GoodType | undefined;
    card?: Card | undefined;
    amountLeft: number;

    constructor(data?: IReturnInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashdesk = data["cashdesk"] ? Cashdesk.fromJS(data["cashdesk"]) : <any>undefined;
            this.checkEntry = data["checkEntry"] ? FullCheckEntryData.fromJS(data["checkEntry"]) : <any>undefined;
            this.right = data["right"] ? Right.fromJS(data["right"]) : <any>undefined;
            this.check = data["check"] ? Check.fromJS(data["check"]) : <any>undefined;
            this.goodType = data["goodType"] ? GoodType.fromJS(data["goodType"]) : <any>undefined;
            this.card = data["card"] ? Card.fromJS(data["card"]) : <any>undefined;
            this.amountLeft = data["amountLeft"];
        }
    }

    static fromJS(data: any): ReturnInfo {
        let result = new ReturnInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashdesk"] = this.cashdesk ? this.cashdesk.toJSON() : <any>undefined;
        data["checkEntry"] = this.checkEntry ? this.checkEntry.toJSON() : <any>undefined;
        data["right"] = this.right ? this.right.toJSON() : <any>undefined;
        data["check"] = this.check ? this.check.toJSON() : <any>undefined;
        data["goodType"] = this.goodType ? this.goodType.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["amountLeft"] = this.amountLeft;
        return data; 
    }
}

export interface IReturnInfo {
    cashdesk?: Cashdesk | undefined;
    checkEntry?: FullCheckEntryData | undefined;
    right?: Right | undefined;
    check?: Check | undefined;
    goodType?: GoodType | undefined;
    card?: Card | undefined;
    amountLeft: number;
}

export class CheckEntryData implements ICheckEntryData {
    entry: CheckEntry = new CheckEntry();
    payments: Payment[] = [];
    checkEntryDiscounts: DiscountValue[] = [];

    constructor(data?: ICheckEntryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entry = data["entry"] ? CheckEntry.fromJS(data["entry"]) : new CheckEntry();
            if (data["payments"] && data["payments"].constructor === Array) {
                this.payments = [];
                for (let item of data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
            if (data["checkEntryDiscounts"] && data["checkEntryDiscounts"].constructor === Array) {
                this.checkEntryDiscounts = [];
                for (let item of data["checkEntryDiscounts"])
                    this.checkEntryDiscounts.push(DiscountValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckEntryData {
        let result = new CheckEntryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entry"] = this.entry ? this.entry.toJSON() : <any>undefined;
        if (this.payments && this.payments.constructor === Array) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        if (this.checkEntryDiscounts && this.checkEntryDiscounts.constructor === Array) {
            data["checkEntryDiscounts"] = [];
            for (let item of this.checkEntryDiscounts)
                data["checkEntryDiscounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICheckEntryData {
    entry: CheckEntry;
    payments: Payment[];
    checkEntryDiscounts: DiscountValue[];
}

export class FullCheckEntryData extends CheckEntryData implements IFullCheckEntryData {
    sellCheckEntryId?: number | undefined;
    sellShiftId?: number | undefined;

    constructor(data?: IFullCheckEntryData) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sellCheckEntryId = data["sellCheckEntryId"];
            this.sellShiftId = data["sellShiftId"];
        }
    }

    static fromJS(data: any): FullCheckEntryData {
        let result = new FullCheckEntryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellCheckEntryId"] = this.sellCheckEntryId;
        data["sellShiftId"] = this.sellShiftId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFullCheckEntryData extends ICheckEntryData {
    sellCheckEntryId?: number | undefined;
    sellShiftId?: number | undefined;
}

export class CheckEntry implements ICheckEntry {
    checkId: number;
    id: number;
    rightId?: number | undefined;
    amount: number;
    price: number;
    basePrice?: number | undefined;
    goodTypeId: number;
    returnCheckEntryId?: number | undefined;
    cardId?: number | undefined;
    userId?: number | undefined;
    printedInQr: boolean;

    constructor(data?: ICheckEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkId = data["checkId"];
            this.id = data["id"];
            this.rightId = data["rightId"];
            this.amount = data["amount"];
            this.price = data["price"];
            this.basePrice = data["basePrice"];
            this.goodTypeId = data["goodTypeId"];
            this.returnCheckEntryId = data["returnCheckEntryId"];
            this.cardId = data["cardId"];
            this.userId = data["userId"];
            this.printedInQr = data["printedInQr"];
        }
    }

    static fromJS(data: any): CheckEntry {
        let result = new CheckEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkId"] = this.checkId;
        data["id"] = this.id;
        data["rightId"] = this.rightId;
        data["amount"] = this.amount;
        data["price"] = this.price;
        data["basePrice"] = this.basePrice;
        data["goodTypeId"] = this.goodTypeId;
        data["returnCheckEntryId"] = this.returnCheckEntryId;
        data["cardId"] = this.cardId;
        data["userId"] = this.userId;
        data["printedInQr"] = this.printedInQr;
        return data; 
    }
}

export interface ICheckEntry {
    checkId: number;
    id: number;
    rightId?: number | undefined;
    amount: number;
    price: number;
    basePrice?: number | undefined;
    goodTypeId: number;
    returnCheckEntryId?: number | undefined;
    cardId?: number | undefined;
    userId?: number | undefined;
    printedInQr: boolean;
}

export class CheckEntryPayment implements ICheckEntryPayment {
    checkEntryId: number;
    id: number;
    processingId: number;
    amount: number;
    transactionReference?: string | undefined;
    accountProcessingId?: number | undefined;

    constructor(data?: ICheckEntryPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkEntryId = data["checkEntryId"];
            this.id = data["id"];
            this.processingId = data["processingId"];
            this.amount = data["amount"];
            this.transactionReference = data["transactionReference"];
            this.accountProcessingId = data["accountProcessingId"];
        }
    }

    static fromJS(data: any): CheckEntryPayment {
        let result = new CheckEntryPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkEntryId"] = this.checkEntryId;
        data["id"] = this.id;
        data["processingId"] = this.processingId;
        data["amount"] = this.amount;
        data["transactionReference"] = this.transactionReference;
        data["accountProcessingId"] = this.accountProcessingId;
        return data; 
    }
}

export interface ICheckEntryPayment {
    checkEntryId: number;
    id: number;
    processingId: number;
    amount: number;
    transactionReference?: string | undefined;
    accountProcessingId?: number | undefined;
}

export class Payment extends CheckEntryPayment implements IPayment {
    cardId?: number | undefined;

    constructor(data?: IPayment) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cardId = data["cardId"];
        }
    }

    static fromJS(data: any): Payment {
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardId"] = this.cardId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPayment extends ICheckEntryPayment {
    cardId?: number | undefined;
}

export class DiscountValue implements IDiscountValue {
    value: number;
    discountId: number;
    discountTypeId: number;
    discountName?: string | undefined;

    constructor(data?: IDiscountValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.discountId = data["discountId"];
            this.discountTypeId = data["discountTypeId"];
            this.discountName = data["discountName"];
        }
    }

    static fromJS(data: any): DiscountValue {
        let result = new DiscountValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["discountId"] = this.discountId;
        data["discountTypeId"] = this.discountTypeId;
        data["discountName"] = this.discountName;
        return data; 
    }
}

export interface IDiscountValue {
    value: number;
    discountId: number;
    discountTypeId: number;
    discountName?: string | undefined;
}

export class Check implements ICheck {
    installationTime: Date;
    id: number;
    installationId: number;
    cashdeskId: number;
    userId: number;
    time: Date;
    type: CheckType;
    administrative: boolean;
    cashdeskShiftId?: number | undefined;
    cashdeskPrinterId?: number | undefined;
    printerShift?: number | undefined;
    printerCheck?: number | undefined;
    printerTime?: Date | undefined;
    fiscalNumber?: string | undefined;
    fiscalDocument?: number | undefined;
    fiscalSign?: string | undefined;
    contact?: string | undefined;

    constructor(data?: ICheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.installationTime = data["installationTime"] ? new Date(data["installationTime"].toString()) : <any>undefined;
            this.id = data["id"];
            this.installationId = data["installationId"];
            this.cashdeskId = data["cashdeskId"];
            this.userId = data["userId"];
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.type = data["type"];
            this.administrative = data["administrative"];
            this.cashdeskShiftId = data["cashdeskShiftId"];
            this.cashdeskPrinterId = data["cashdeskPrinterId"];
            this.printerShift = data["printerShift"];
            this.printerCheck = data["printerCheck"];
            this.printerTime = data["printerTime"] ? new Date(data["printerTime"].toString()) : <any>undefined;
            this.fiscalNumber = data["fiscalNumber"];
            this.fiscalDocument = data["fiscalDocument"];
            this.fiscalSign = data["fiscalSign"];
            this.contact = data["contact"];
        }
    }

    static fromJS(data: any): Check {
        let result = new Check();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationTime"] = this.installationTime ? this.installationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["installationId"] = this.installationId;
        data["cashdeskId"] = this.cashdeskId;
        data["userId"] = this.userId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["administrative"] = this.administrative;
        data["cashdeskShiftId"] = this.cashdeskShiftId;
        data["cashdeskPrinterId"] = this.cashdeskPrinterId;
        data["printerShift"] = this.printerShift;
        data["printerCheck"] = this.printerCheck;
        data["printerTime"] = this.printerTime ? this.printerTime.toISOString() : <any>undefined;
        data["fiscalNumber"] = this.fiscalNumber;
        data["fiscalDocument"] = this.fiscalDocument;
        data["fiscalSign"] = this.fiscalSign;
        data["contact"] = this.contact;
        return data; 
    }
}

export interface ICheck {
    installationTime: Date;
    id: number;
    installationId: number;
    cashdeskId: number;
    userId: number;
    time: Date;
    type: CheckType;
    administrative: boolean;
    cashdeskShiftId?: number | undefined;
    cashdeskPrinterId?: number | undefined;
    printerShift?: number | undefined;
    printerCheck?: number | undefined;
    printerTime?: Date | undefined;
    fiscalNumber?: string | undefined;
    fiscalDocument?: number | undefined;
    fiscalSign?: string | undefined;
    contact?: string | undefined;
}

export enum CheckType {
    Sell = 0, 
    Return = 1, 
}

export class GetReturnInfoByChecksRequest implements IGetReturnInfoByChecksRequest {
    /** Cashdesk where rerurn would be done */
    cashdeskId: number;
    /** Seek for checks from  */
    from: Date;
    /** Seek for checks to */
    to: Date;
    /** Cashdesk where the sell was done (optional) */
    sellCashDeskId?: number | undefined;
    /** Current cashdesk time */
    time: Date;
    /** If show checks made in administrative mode */
    showAdministrativeChecks: boolean;
    /** Current installation id */
    installationId: number;
    /** If filter by particular check */
    checkId?: number | undefined;

    constructor(data?: IGetReturnInfoByChecksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashdeskId = data["cashdeskId"];
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.sellCashDeskId = data["sellCashDeskId"];
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.showAdministrativeChecks = data["showAdministrativeChecks"];
            this.installationId = data["installationId"];
            this.checkId = data["checkId"];
        }
    }

    static fromJS(data: any): GetReturnInfoByChecksRequest {
        let result = new GetReturnInfoByChecksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashdeskId"] = this.cashdeskId;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["sellCashDeskId"] = this.sellCashDeskId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["showAdministrativeChecks"] = this.showAdministrativeChecks;
        data["installationId"] = this.installationId;
        data["checkId"] = this.checkId;
        return data; 
    }
}

export interface IGetReturnInfoByChecksRequest {
    /** Cashdesk where rerurn would be done */
    cashdeskId: number;
    /** Seek for checks from  */
    from: Date;
    /** Seek for checks to */
    to: Date;
    /** Cashdesk where the sell was done (optional) */
    sellCashDeskId?: number | undefined;
    /** Current cashdesk time */
    time: Date;
    /** If show checks made in administrative mode */
    showAdministrativeChecks: boolean;
    /** Current installation id */
    installationId: number;
    /** If filter by particular check */
    checkId?: number | undefined;
}

export class TransactionView implements ITransactionView {
    rightId: number;
    time: Date;
    installationTime: Date;
    payName: string;
    goodName: string;
    payAmount: number;
    goodAmount?: number | undefined;
    cost?: number | undefined;
    place: string;
    user?: string | undefined;
    type?: string | undefined;
    checkEntryId?: number | undefined;
    serviceSellId?: number | undefined;
    installationId: number;
    cardId?: number | undefined;
    userId?: number | undefined;

    constructor(data?: ITransactionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rightId = data["rightId"];
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.installationTime = data["installationTime"] ? new Date(data["installationTime"].toString()) : <any>undefined;
            this.payName = data["payName"];
            this.goodName = data["goodName"];
            this.payAmount = data["payAmount"];
            this.goodAmount = data["goodAmount"];
            this.cost = data["cost"];
            this.place = data["place"];
            this.user = data["user"];
            this.type = data["type"];
            this.checkEntryId = data["checkEntryId"];
            this.serviceSellId = data["serviceSellId"];
            this.installationId = data["installationId"];
            this.cardId = data["cardId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): TransactionView {
        let result = new TransactionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rightId"] = this.rightId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["installationTime"] = this.installationTime ? this.installationTime.toISOString() : <any>undefined;
        data["payName"] = this.payName;
        data["goodName"] = this.goodName;
        data["payAmount"] = this.payAmount;
        data["goodAmount"] = this.goodAmount;
        data["cost"] = this.cost;
        data["place"] = this.place;
        data["user"] = this.user;
        data["type"] = this.type;
        data["checkEntryId"] = this.checkEntryId;
        data["serviceSellId"] = this.serviceSellId;
        data["installationId"] = this.installationId;
        data["cardId"] = this.cardId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ITransactionView {
    rightId: number;
    time: Date;
    installationTime: Date;
    payName: string;
    goodName: string;
    payAmount: number;
    goodAmount?: number | undefined;
    cost?: number | undefined;
    place: string;
    user?: string | undefined;
    type?: string | undefined;
    checkEntryId?: number | undefined;
    serviceSellId?: number | undefined;
    installationId: number;
    cardId?: number | undefined;
    userId?: number | undefined;
}

export class CalculateDiscountsRequest implements ICalculateDiscountsRequest {
    checkEntries: CheckEntryDescriptor[] = [];
    discountIds?: number[] | undefined;
    currentDateTime: Date;

    constructor(data?: ICalculateDiscountsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["checkEntries"] && data["checkEntries"].constructor === Array) {
                this.checkEntries = [];
                for (let item of data["checkEntries"])
                    this.checkEntries.push(CheckEntryDescriptor.fromJS(item));
            }
            if (data["discountIds"] && data["discountIds"].constructor === Array) {
                this.discountIds = [];
                for (let item of data["discountIds"])
                    this.discountIds.push(item);
            }
            this.currentDateTime = data["currentDateTime"] ? new Date(data["currentDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CalculateDiscountsRequest {
        let result = new CalculateDiscountsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.checkEntries && this.checkEntries.constructor === Array) {
            data["checkEntries"] = [];
            for (let item of this.checkEntries)
                data["checkEntries"].push(item.toJSON());
        }
        if (this.discountIds && this.discountIds.constructor === Array) {
            data["discountIds"] = [];
            for (let item of this.discountIds)
                data["discountIds"].push(item);
        }
        data["currentDateTime"] = this.currentDateTime ? this.currentDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICalculateDiscountsRequest {
    checkEntries: CheckEntryDescriptor[];
    discountIds?: number[] | undefined;
    currentDateTime: Date;
}

export class CheckEntryDescriptor implements ICheckEntryDescriptor {
    goodTypeId: number;
    price: number;
    index: number;

    constructor(data?: ICheckEntryDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.goodTypeId = data["goodTypeId"];
            this.price = data["price"];
            this.index = data["index"];
        }
    }

    static fromJS(data: any): CheckEntryDescriptor {
        let result = new CheckEntryDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodTypeId"] = this.goodTypeId;
        data["price"] = this.price;
        data["index"] = this.index;
        return data; 
    }
}

export interface ICheckEntryDescriptor {
    goodTypeId: number;
    price: number;
    index: number;
}

export class CheckEntryDiscount implements ICheckEntryDiscount {
    checkEntryOrdinal: number;
    values?: DiscountValue[] | undefined;

    constructor(data?: ICheckEntryDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkEntryOrdinal = data["checkEntryOrdinal"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(DiscountValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckEntryDiscount {
        let result = new CheckEntryDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkEntryOrdinal"] = this.checkEntryOrdinal;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICheckEntryDiscount {
    checkEntryOrdinal: number;
    values?: DiscountValue[] | undefined;
}

export class CardReaderSettings implements ICardReaderSettings {
    port: number;
    baudRate: number;
    dataBits: number;
    stopBits: StopBits;
    parity: Parity;
    handshake: Handshake;
    timeOut: number;
    dtrEnable: boolean;
    rtsEnable: boolean;
    driver: CardReader;

    constructor(data?: ICardReaderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.port = data["port"];
            this.baudRate = data["baudRate"];
            this.dataBits = data["dataBits"];
            this.stopBits = data["stopBits"];
            this.parity = data["parity"];
            this.handshake = data["handshake"];
            this.timeOut = data["timeOut"];
            this.dtrEnable = data["dtrEnable"];
            this.rtsEnable = data["rtsEnable"];
            this.driver = data["driver"];
        }
    }

    static fromJS(data: any): CardReaderSettings {
        let result = new CardReaderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["port"] = this.port;
        data["baudRate"] = this.baudRate;
        data["dataBits"] = this.dataBits;
        data["stopBits"] = this.stopBits;
        data["parity"] = this.parity;
        data["handshake"] = this.handshake;
        data["timeOut"] = this.timeOut;
        data["dtrEnable"] = this.dtrEnable;
        data["rtsEnable"] = this.rtsEnable;
        data["driver"] = this.driver;
        return data; 
    }
}

export interface ICardReaderSettings {
    port: number;
    baudRate: number;
    dataBits: number;
    stopBits: StopBits;
    parity: Parity;
    handshake: Handshake;
    timeOut: number;
    dtrEnable: boolean;
    rtsEnable: boolean;
    driver: CardReader;
}

export enum StopBits {
    None = 0, 
    One = 1, 
    Two = 2, 
    OnePointFive = 3, 
}

export enum Parity {
    None = 0, 
    Odd = 1, 
    Even = 2, 
    Mark = 3, 
    Space = 4, 
}

export enum Handshake {
    None = 0, 
    XOnXOff = 1, 
    RequestToSend = 2, 
    RequestToSendXOnXOff = 3, 
}

export enum CardReader {
    Prox = 0, 
}

export class GetChecksByGoodsRequest implements IGetChecksByGoodsRequest {
    goodIds?: number[] | undefined;

    constructor(data?: IGetChecksByGoodsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["goodIds"] && data["goodIds"].constructor === Array) {
                this.goodIds = [];
                for (let item of data["goodIds"])
                    this.goodIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetChecksByGoodsRequest {
        let result = new GetChecksByGoodsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.goodIds && this.goodIds.constructor === Array) {
            data["goodIds"] = [];
            for (let item of this.goodIds)
                data["goodIds"].push(item);
        }
        return data; 
    }
}

export interface IGetChecksByGoodsRequest {
    goodIds?: number[] | undefined;
}

export class GetChecksByGoodsResponse implements IGetChecksByGoodsResponse {
    checks?: CheckDescriptor[] | undefined;

    constructor(data?: IGetChecksByGoodsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["checks"] && data["checks"].constructor === Array) {
                this.checks = [];
                for (let item of data["checks"])
                    this.checks.push(CheckDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetChecksByGoodsResponse {
        let result = new GetChecksByGoodsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.checks && this.checks.constructor === Array) {
            data["checks"] = [];
            for (let item of this.checks)
                data["checks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetChecksByGoodsResponse {
    checks?: CheckDescriptor[] | undefined;
}

export class CheckDescriptor implements ICheckDescriptor {
    checkId: number;
    goodIds?: number[] | undefined;

    constructor(data?: ICheckDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkId = data["checkId"];
            if (data["goodIds"] && data["goodIds"].constructor === Array) {
                this.goodIds = [];
                for (let item of data["goodIds"])
                    this.goodIds.push(item);
            }
        }
    }

    static fromJS(data: any): CheckDescriptor {
        let result = new CheckDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkId"] = this.checkId;
        if (this.goodIds && this.goodIds.constructor === Array) {
            data["goodIds"] = [];
            for (let item of this.goodIds)
                data["goodIds"].push(item);
        }
        return data; 
    }
}

export interface ICheckDescriptor {
    checkId: number;
    goodIds?: number[] | undefined;
}

export class GetClientInfoResponse implements IGetClientInfoResponse {
    cards?: CardInfoResponse[] | undefined;
    userData?: UserData | undefined;
    transactions?: TransactionView[] | undefined;

    constructor(data?: IGetClientInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cards"] && data["cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["cards"])
                    this.cards.push(CardInfoResponse.fromJS(item));
            }
            this.userData = data["userData"] ? UserData.fromJS(data["userData"]) : <any>undefined;
            if (data["transactions"] && data["transactions"].constructor === Array) {
                this.transactions = [];
                for (let item of data["transactions"])
                    this.transactions.push(TransactionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetClientInfoResponse {
        let result = new GetClientInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cards && this.cards.constructor === Array) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        data["userData"] = this.userData ? this.userData.toJSON() : <any>undefined;
        if (this.transactions && this.transactions.constructor === Array) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetClientInfoResponse {
    cards?: CardInfoResponse[] | undefined;
    userData?: UserData | undefined;
    transactions?: TransactionView[] | undefined;
}

export class Installation implements IInstallation {
    id: number;
    name: string;
    description: string;
    timeZone: number;
    creationTime: Date;

    constructor(data?: IInstallation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.timeZone = data["timeZone"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Installation {
        let result = new Installation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["timeZone"] = this.timeZone;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IInstallation {
    id: number;
    name: string;
    description: string;
    timeZone: number;
    creationTime: Date;
}

export class ShiftResponse implements IShiftResponse {
    shift?: CashdeskShift | undefined;
    openerName?: string | undefined;
    closerName?: string | undefined;

    constructor(data?: IShiftResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shift = data["shift"] ? CashdeskShift.fromJS(data["shift"]) : <any>undefined;
            this.openerName = data["openerName"];
            this.closerName = data["closerName"];
        }
    }

    static fromJS(data: any): ShiftResponse {
        let result = new ShiftResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shift"] = this.shift ? this.shift.toJSON() : <any>undefined;
        data["openerName"] = this.openerName;
        data["closerName"] = this.closerName;
        return data; 
    }
}

export interface IShiftResponse {
    shift?: CashdeskShift | undefined;
    openerName?: string | undefined;
    closerName?: string | undefined;
}

export class CashdeskShift implements ICashdeskShift {
    id: number;
    cashdeskId: number;
    openTime: Date;
    openUserId: number;
    closeTime?: Date | undefined;
    closeUserId?: number | undefined;

    constructor(data?: ICashdeskShift) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cashdeskId = data["cashdeskId"];
            this.openTime = data["openTime"] ? new Date(data["openTime"].toString()) : <any>undefined;
            this.openUserId = data["openUserId"];
            this.closeTime = data["closeTime"] ? new Date(data["closeTime"].toString()) : <any>undefined;
            this.closeUserId = data["closeUserId"];
        }
    }

    static fromJS(data: any): CashdeskShift {
        let result = new CashdeskShift();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cashdeskId"] = this.cashdeskId;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>undefined;
        data["openUserId"] = this.openUserId;
        data["closeTime"] = this.closeTime ? this.closeTime.toISOString() : <any>undefined;
        data["closeUserId"] = this.closeUserId;
        return data; 
    }
}

export interface ICashdeskShift {
    id: number;
    cashdeskId: number;
    openTime: Date;
    openUserId: number;
    closeTime?: Date | undefined;
    closeUserId?: number | undefined;
}

export class PosDisplaySettings implements IPosDisplaySettings {
    portNumber: number;
    baudRate: number;
    characterSet: number;

    constructor(data?: IPosDisplaySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.portNumber = data["portNumber"];
            this.baudRate = data["baudRate"];
            this.characterSet = data["characterSet"];
        }
    }

    static fromJS(data: any): PosDisplaySettings {
        let result = new PosDisplaySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["portNumber"] = this.portNumber;
        data["baudRate"] = this.baudRate;
        data["characterSet"] = this.characterSet;
        return data; 
    }
}

export interface IPosDisplaySettings {
    portNumber: number;
    baudRate: number;
    characterSet: number;
}

export class Tariff implements ITariff {
    id: number;
    name: string;
    validityDateFrom: Date;
    validityDateTo: Date;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    dayOfWeek?: DayOfWeek | undefined;
    dayTypeId?: number | undefined;
    goodTypeId?: number | undefined;
    priceType: PriceType;
    priceValue: number;
    calendarId?: number | undefined;
    installationId: number;
    organizationId?: number | undefined;

    constructor(data?: ITariff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.validityDateFrom = data["validityDateFrom"] ? new Date(data["validityDateFrom"].toString()) : <any>undefined;
            this.validityDateTo = data["validityDateTo"] ? new Date(data["validityDateTo"].toString()) : <any>undefined;
            this.timeFrom = data["timeFrom"];
            this.timeTo = data["timeTo"];
            this.dayOfWeek = data["dayOfWeek"];
            this.dayTypeId = data["dayTypeId"];
            this.goodTypeId = data["goodTypeId"];
            this.priceType = data["priceType"];
            this.priceValue = data["priceValue"];
            this.calendarId = data["calendarId"];
            this.installationId = data["installationId"];
            this.organizationId = data["organizationId"];
        }
    }

    static fromJS(data: any): Tariff {
        let result = new Tariff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["validityDateFrom"] = this.validityDateFrom ? this.validityDateFrom.toISOString() : <any>undefined;
        data["validityDateTo"] = this.validityDateTo ? this.validityDateTo.toISOString() : <any>undefined;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["dayOfWeek"] = this.dayOfWeek;
        data["dayTypeId"] = this.dayTypeId;
        data["goodTypeId"] = this.goodTypeId;
        data["priceType"] = this.priceType;
        data["priceValue"] = this.priceValue;
        data["calendarId"] = this.calendarId;
        data["installationId"] = this.installationId;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface ITariff {
    id: number;
    name: string;
    validityDateFrom: Date;
    validityDateTo: Date;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    dayOfWeek?: DayOfWeek | undefined;
    dayTypeId?: number | undefined;
    goodTypeId?: number | undefined;
    priceType: PriceType;
    priceValue: number;
    calendarId?: number | undefined;
    installationId: number;
    organizationId?: number | undefined;
}

export enum DayOfWeek {
    Sunday = 0, 
    Monday = 1, 
    Tuesday = 2, 
    Wednesday = 3, 
    Thursday = 4, 
    Friday = 5, 
    Saturday = 6, 
}

export enum PriceType {
    Absolute = 0, 
    Fractional = 1, 
    Defining = 2, 
}

export class RsaKey implements IRsaKey {
    exponent?: string | undefined;
    modulus?: string | undefined;
    dp?: string | undefined;
    dq?: string | undefined;
    p?: string | undefined;
    publicExponent?: string | undefined;
    q?: string | undefined;
    qInv?: string | undefined;

    constructor(data?: IRsaKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exponent = data["exponent"];
            this.modulus = data["modulus"];
            this.dp = data["dp"];
            this.dq = data["dq"];
            this.p = data["p"];
            this.publicExponent = data["publicExponent"];
            this.q = data["q"];
            this.qInv = data["qInv"];
        }
    }

    static fromJS(data: any): RsaKey {
        let result = new RsaKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exponent"] = this.exponent;
        data["modulus"] = this.modulus;
        data["dp"] = this.dp;
        data["dq"] = this.dq;
        data["p"] = this.p;
        data["publicExponent"] = this.publicExponent;
        data["q"] = this.q;
        data["qInv"] = this.qInv;
        return data; 
    }
}

export interface IRsaKey {
    exponent?: string | undefined;
    modulus?: string | undefined;
    dp?: string | undefined;
    dq?: string | undefined;
    p?: string | undefined;
    publicExponent?: string | undefined;
    q?: string | undefined;
    qInv?: string | undefined;
}

export class SpicesBasket implements ISpicesBasket {
    peper?: string | undefined;
    vanilla: string;
    crc?: string | undefined;

    constructor(data?: ISpicesBasket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.peper = data["peper"];
            this.vanilla = data["vanilla"];
            this.crc = data["crc"];
        }
    }

    static fromJS(data: any): SpicesBasket {
        let result = new SpicesBasket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["peper"] = this.peper;
        data["vanilla"] = this.vanilla;
        data["crc"] = this.crc;
        return data; 
    }
}

export interface ISpicesBasket {
    peper?: string | undefined;
    vanilla: string;
    crc?: string | undefined;
}

export class PutCheckRequest implements IPutCheckRequest {
    check: Check = new Check();
    entries: FullCheckEntryData[] = [];

    constructor(data?: IPutCheckRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.check = data["check"] ? Check.fromJS(data["check"]) : new Check();
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(FullCheckEntryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutCheckRequest {
        let result = new PutCheckRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["check"] = this.check ? this.check.toJSON() : <any>undefined;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPutCheckRequest {
    check: Check;
    entries: FullCheckEntryData[];
}

export class PutCheckResponce implements IPutCheckResponce {
    check?: Check | undefined;
    entries?: FullCheckEntryData[] | undefined;

    constructor(data?: IPutCheckResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.check = data["check"] ? Check.fromJS(data["check"]) : <any>undefined;
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(FullCheckEntryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutCheckResponce {
        let result = new PutCheckResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["check"] = this.check ? this.check.toJSON() : <any>undefined;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPutCheckResponce {
    check?: Check | undefined;
    entries?: FullCheckEntryData[] | undefined;
}

export class DayType implements IDayType {
    id: number;
    name: string;
    installationId: number;

    constructor(data?: IDayType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.installationId = data["installationId"];
        }
    }

    static fromJS(data: any): DayType {
        let result = new DayType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        return data; 
    }
}

export interface IDayType {
    id: number;
    name: string;
    installationId: number;
}

export class DayTypesSelectRequest extends SelectRequestBaseOfInstallationFilter implements IDayTypesSelectRequest {

    constructor(data?: IDayTypesSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DayTypesSelectRequest {
        let result = new DayTypesSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDayTypesSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfDayTypeView implements ISelectResponceBaseOfDayTypeView {
    data?: DayTypeView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfDayTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(DayTypeView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfDayTypeView {
        let result = new SelectResponceBaseOfDayTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfDayTypeView {
    data?: DayTypeView[] | undefined;
    total: number;
}

export class DayTypesSelectResponce extends SelectResponceBaseOfDayTypeView implements IDayTypesSelectResponce {

    constructor(data?: IDayTypesSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DayTypesSelectResponce {
        let result = new DayTypesSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDayTypesSelectResponce extends ISelectResponceBaseOfDayTypeView {
}

/** Represents T:Jade.Api.Database.DayType view with referenced entity names */
export class DayTypeView extends DayType implements IDayTypeView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.DayType.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IDayTypeView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): DayTypeView {
        let result = new DayTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.DayType view with referenced entity names */
export interface IDayTypeView extends IDayType {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.DayType.InstallationId */
    installationName?: string | undefined;
}

export class DiscountTypeToGoodTypeEntry implements IDiscountTypeToGoodTypeEntry {
    goodType: GoodTypeView = new GoodTypeView();
    bound?: DiscountTypeToGoodType | undefined;

    constructor(data?: IDiscountTypeToGoodTypeEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.goodType = data["goodType"] ? GoodTypeView.fromJS(data["goodType"]) : new GoodTypeView();
            this.bound = data["bound"] ? DiscountTypeToGoodType.fromJS(data["bound"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscountTypeToGoodTypeEntry {
        let result = new DiscountTypeToGoodTypeEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodType"] = this.goodType ? this.goodType.toJSON() : <any>undefined;
        data["bound"] = this.bound ? this.bound.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDiscountTypeToGoodTypeEntry {
    goodType: GoodTypeView;
    bound?: DiscountTypeToGoodType | undefined;
}

/** Represents T:Jade.Api.Database.GoodType view with referenced entity names */
export class GoodTypeView extends GoodType implements IGoodTypeView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodTypeTree.Name of T:Jade.Api.Database.GoodTypeTree referenced by P:Jade.Api.Database.GoodType.GoodTypeTreeId */
    goodTypeTreeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.GoodType.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.TimeLimitation.Name of T:Jade.Api.Database.TimeLimitation referenced by P:Jade.Api.Database.GoodType.TimeLimitationId */
    timeLimitationName?: string | undefined;

    constructor(data?: IGoodTypeView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.goodTypeTreeName = data["goodTypeTreeName"];
            this.organizationName = data["organizationName"];
            this.timeLimitationName = data["timeLimitationName"];
        }
    }

    static fromJS(data: any): GoodTypeView {
        let result = new GoodTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["goodTypeTreeName"] = this.goodTypeTreeName;
        data["organizationName"] = this.organizationName;
        data["timeLimitationName"] = this.timeLimitationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.GoodType view with referenced entity names */
export interface IGoodTypeView extends IGoodType {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodTypeTree.Name of T:Jade.Api.Database.GoodTypeTree referenced by P:Jade.Api.Database.GoodType.GoodTypeTreeId */
    goodTypeTreeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.GoodType.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.TimeLimitation.Name of T:Jade.Api.Database.TimeLimitation referenced by P:Jade.Api.Database.GoodType.TimeLimitationId */
    timeLimitationName?: string | undefined;
}

export class DiscountTypeToGoodType implements IDiscountTypeToGoodType {
    discountTypeId: number;
    goodTypeId: number;
    amount: number;

    constructor(data?: IDiscountTypeToGoodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.discountTypeId = data["discountTypeId"];
            this.goodTypeId = data["goodTypeId"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): DiscountTypeToGoodType {
        let result = new DiscountTypeToGoodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountTypeId"] = this.discountTypeId;
        data["goodTypeId"] = this.goodTypeId;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IDiscountTypeToGoodType {
    discountTypeId: number;
    goodTypeId: number;
    amount: number;
}

export class DiscountTypesSelectRequest extends SelectRequestBaseOfInstallationFilter implements IDiscountTypesSelectRequest {

    constructor(data?: IDiscountTypesSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DiscountTypesSelectRequest {
        let result = new DiscountTypesSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDiscountTypesSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfDiscountTypeView implements ISelectResponceBaseOfDiscountTypeView {
    data?: DiscountTypeView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfDiscountTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(DiscountTypeView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfDiscountTypeView {
        let result = new SelectResponceBaseOfDiscountTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfDiscountTypeView {
    data?: DiscountTypeView[] | undefined;
    total: number;
}

export class DiscountTypesSelectResponce extends SelectResponceBaseOfDiscountTypeView implements IDiscountTypesSelectResponce {

    constructor(data?: IDiscountTypesSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DiscountTypesSelectResponce {
        let result = new DiscountTypesSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDiscountTypesSelectResponce extends ISelectResponceBaseOfDiscountTypeView {
}

/** Represents T:Jade.Api.Database.DiscountType view with referenced entity names */
export class DiscountTypeView extends DiscountType implements IDiscountTypeView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.DiscountType.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IDiscountTypeView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): DiscountTypeView {
        let result = new DiscountTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.DiscountType view with referenced entity names */
export interface IDiscountTypeView extends IDiscountType {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.DiscountType.InstallationId */
    installationName?: string | undefined;
}

export class SelectRequestBaseOfGoodTypeFilter implements ISelectRequestBaseOfGoodTypeFilter {
    filter: GoodTypeFilter = new GoodTypeFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfGoodTypeFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? GoodTypeFilter.fromJS(data["filter"]) : new GoodTypeFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfGoodTypeFilter {
        let result = new SelectRequestBaseOfGoodTypeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfGoodTypeFilter {
    filter: GoodTypeFilter;
    page: Paginator;
}

export class GoodTypesSelectRequest extends SelectRequestBaseOfGoodTypeFilter implements IGoodTypesSelectRequest {

    constructor(data?: IGoodTypesSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GoodTypesSelectRequest {
        let result = new GoodTypesSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypesSelectRequest extends ISelectRequestBaseOfGoodTypeFilter {
}

export class GoodTypeFilter extends InstallationFilter implements IGoodTypeFilter {
    kind?: GoodTypeKind | undefined;

    constructor(data?: IGoodTypeFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.kind = data["kind"];
        }
    }

    static fromJS(data: any): GoodTypeFilter {
        let result = new GoodTypeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypeFilter extends IInstallationFilter {
    kind?: GoodTypeKind | undefined;
}

export class SelectResponceBaseOfGoodTypeView implements ISelectResponceBaseOfGoodTypeView {
    data?: GoodTypeView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfGoodTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(GoodTypeView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfGoodTypeView {
        let result = new SelectResponceBaseOfGoodTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfGoodTypeView {
    data?: GoodTypeView[] | undefined;
    total: number;
}

export class GoodTypesSelectResponce extends SelectResponceBaseOfGoodTypeView implements IGoodTypesSelectResponce {

    constructor(data?: IGoodTypesSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GoodTypesSelectResponce {
        let result = new GoodTypesSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypesSelectResponce extends ISelectResponceBaseOfGoodTypeView {
}

export class GoodTypeTreesSelectRequest extends SelectRequestBaseOfInstallationFilter implements IGoodTypeTreesSelectRequest {

    constructor(data?: IGoodTypeTreesSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GoodTypeTreesSelectRequest {
        let result = new GoodTypeTreesSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypeTreesSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfGoodTypeTreeView implements ISelectResponceBaseOfGoodTypeTreeView {
    data?: GoodTypeTreeView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfGoodTypeTreeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(GoodTypeTreeView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfGoodTypeTreeView {
        let result = new SelectResponceBaseOfGoodTypeTreeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfGoodTypeTreeView {
    data?: GoodTypeTreeView[] | undefined;
    total: number;
}

export class GoodTypeTreesSelectResponce extends SelectResponceBaseOfGoodTypeTreeView implements IGoodTypeTreesSelectResponce {

    constructor(data?: IGoodTypeTreesSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GoodTypeTreesSelectResponce {
        let result = new GoodTypeTreesSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGoodTypeTreesSelectResponce extends ISelectResponceBaseOfGoodTypeTreeView {
}

/** Represents T:Jade.Api.Database.GoodTypeTree view with referenced entity names */
export class GoodTypeTreeView extends GoodTypeTree implements IGoodTypeTreeView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodTypeTree.Name of T:Jade.Api.Database.GoodTypeTree referenced by P:Jade.Api.Database.GoodTypeTree.ParentId */
    goodTypeTreeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.GoodTypeTree.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IGoodTypeTreeView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.goodTypeTreeName = data["goodTypeTreeName"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): GoodTypeTreeView {
        let result = new GoodTypeTreeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["goodTypeTreeName"] = this.goodTypeTreeName;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.GoodTypeTree view with referenced entity names */
export interface IGoodTypeTreeView extends IGoodTypeTree {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodTypeTree.Name of T:Jade.Api.Database.GoodTypeTree referenced by P:Jade.Api.Database.GoodTypeTree.ParentId */
    goodTypeTreeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.GoodTypeTree.InstallationId */
    installationName?: string | undefined;
}

export class HardwareControllerResponceBase implements IHardwareControllerResponceBase {
    id: number;

    constructor(data?: IHardwareControllerResponceBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HardwareControllerResponceBase {
        let result = new HardwareControllerResponceBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IHardwareControllerResponceBase {
    id: number;
}

export class HardwareControllerSettingsResponce extends HardwareControllerResponceBase implements IHardwareControllerSettingsResponce {
    serviceId: number;
    name?: string | undefined;
    timeZone: number;
    refreshTime: number;
    time: number;
    maxTransactionId: number;
    maxPassId: number;
    passMessages?: PassMessage[] | undefined;
    allowOnlineCheckPass: number;
    allowSoftOffline: number;
    onlineRequestTimeout: number;

    constructor(data?: IHardwareControllerSettingsResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceId = data["serviceId"];
            this.name = data["name"];
            this.timeZone = data["timeZone"];
            this.refreshTime = data["refreshTime"];
            this.time = data["time"];
            this.maxTransactionId = data["maxTransactionId"];
            this.maxPassId = data["maxPassId"];
            if (data["passMessages"] && data["passMessages"].constructor === Array) {
                this.passMessages = [];
                for (let item of data["passMessages"])
                    this.passMessages.push(PassMessage.fromJS(item));
            }
            this.allowOnlineCheckPass = data["allowOnlineCheckPass"];
            this.allowSoftOffline = data["allowSoftOffline"];
            this.onlineRequestTimeout = data["onlineRequestTimeout"];
        }
    }

    static fromJS(data: any): HardwareControllerSettingsResponce {
        let result = new HardwareControllerSettingsResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["name"] = this.name;
        data["timeZone"] = this.timeZone;
        data["refreshTime"] = this.refreshTime;
        data["time"] = this.time;
        data["maxTransactionId"] = this.maxTransactionId;
        data["maxPassId"] = this.maxPassId;
        if (this.passMessages && this.passMessages.constructor === Array) {
            data["passMessages"] = [];
            for (let item of this.passMessages)
                data["passMessages"].push(item.toJSON());
        }
        data["allowOnlineCheckPass"] = this.allowOnlineCheckPass;
        data["allowSoftOffline"] = this.allowSoftOffline;
        data["onlineRequestTimeout"] = this.onlineRequestTimeout;
        super.toJSON(data);
        return data; 
    }
}

export interface IHardwareControllerSettingsResponce extends IHardwareControllerResponceBase {
    serviceId: number;
    name?: string | undefined;
    timeZone: number;
    refreshTime: number;
    time: number;
    maxTransactionId: number;
    maxPassId: number;
    passMessages?: PassMessage[] | undefined;
    allowOnlineCheckPass: number;
    allowSoftOffline: number;
    onlineRequestTimeout: number;
}

export class PassMessage implements IPassMessage {
    key?: string | undefined;
    messageTemplate?: string | undefined;

    constructor(data?: IPassMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.messageTemplate = data["messageTemplate"];
        }
    }

    static fromJS(data: any): PassMessage {
        let result = new PassMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["messageTemplate"] = this.messageTemplate;
        return data; 
    }
}

export interface IPassMessage {
    key?: string | undefined;
    messageTemplate?: string | undefined;
}

export class HardwareControllerTariffResponce extends HardwareControllerResponceBase implements IHardwareControllerTariffResponce {
    tariffs?: HardwareControllerTariff[] | undefined;

    constructor(data?: IHardwareControllerTariffResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["tariffs"] && data["tariffs"].constructor === Array) {
                this.tariffs = [];
                for (let item of data["tariffs"])
                    this.tariffs.push(HardwareControllerTariff.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HardwareControllerTariffResponce {
        let result = new HardwareControllerTariffResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tariffs && this.tariffs.constructor === Array) {
            data["tariffs"] = [];
            for (let item of this.tariffs)
                data["tariffs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IHardwareControllerTariffResponce extends IHardwareControllerResponceBase {
    tariffs?: HardwareControllerTariff[] | undefined;
}

export class HardwareControllerTariff implements IHardwareControllerTariff {
    rightTypeId: number;
    serviceId: number;
    from: number;
    to: number;
    delay: number;
    order: number;
    amount: number;
    amountMultiplier: number;
    checkLastAmount: number;
    rightName: string;

    constructor(data?: IHardwareControllerTariff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rightTypeId = data["rightTypeId"];
            this.serviceId = data["serviceId"];
            this.from = data["from"];
            this.to = data["to"];
            this.delay = data["delay"];
            this.order = data["order"];
            this.amount = data["amount"];
            this.amountMultiplier = data["amountMultiplier"];
            this.checkLastAmount = data["checkLastAmount"];
            this.rightName = data["rightName"];
        }
    }

    static fromJS(data: any): HardwareControllerTariff {
        let result = new HardwareControllerTariff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rightTypeId"] = this.rightTypeId;
        data["serviceId"] = this.serviceId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["delay"] = this.delay;
        data["order"] = this.order;
        data["amount"] = this.amount;
        data["amountMultiplier"] = this.amountMultiplier;
        data["checkLastAmount"] = this.checkLastAmount;
        data["rightName"] = this.rightName;
        return data; 
    }
}

export interface IHardwareControllerTariff {
    rightTypeId: number;
    serviceId: number;
    from: number;
    to: number;
    delay: number;
    order: number;
    amount: number;
    amountMultiplier: number;
    checkLastAmount: number;
    rightName: string;
}

export class HardwareControllerLogResponce extends HardwareControllerResponceBase implements IHardwareControllerLogResponce {
    recordsInserted: number;

    constructor(data?: IHardwareControllerLogResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.recordsInserted = data["recordsInserted"];
        }
    }

    static fromJS(data: any): HardwareControllerLogResponce {
        let result = new HardwareControllerLogResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordsInserted"] = this.recordsInserted;
        super.toJSON(data);
        return data; 
    }
}

export interface IHardwareControllerLogResponce extends IHardwareControllerResponceBase {
    recordsInserted: number;
}

export class HardwareControllerValidatePassResponce extends HardwareControllerResponceBase implements IHardwareControllerValidatePassResponce {
    success: number;
    message?: string | undefined;

    constructor(data?: IHardwareControllerValidatePassResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.success = data["success"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): HardwareControllerValidatePassResponce {
        let result = new HardwareControllerValidatePassResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IHardwareControllerValidatePassResponce extends IHardwareControllerResponceBase {
    success: number;
    message?: string | undefined;
}

export class HardwareControllerFirmwareResponce extends HardwareControllerResponceBase implements IHardwareControllerFirmwareResponce {
    version?: string | undefined;
    versionMajor: number;
    versionMinor: number;
    versionRevision: number;
    versionHash?: string | undefined;
    releaseTime: number;
    success: number;
    firmwareId: number;
    execute?: string | undefined;

    constructor(data?: IHardwareControllerFirmwareResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.version = data["version"];
            this.versionMajor = data["versionMajor"];
            this.versionMinor = data["versionMinor"];
            this.versionRevision = data["versionRevision"];
            this.versionHash = data["versionHash"];
            this.releaseTime = data["releaseTime"];
            this.success = data["success"];
            this.firmwareId = data["firmwareId"];
            this.execute = data["execute"];
        }
    }

    static fromJS(data: any): HardwareControllerFirmwareResponce {
        let result = new HardwareControllerFirmwareResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["versionMajor"] = this.versionMajor;
        data["versionMinor"] = this.versionMinor;
        data["versionRevision"] = this.versionRevision;
        data["versionHash"] = this.versionHash;
        data["releaseTime"] = this.releaseTime;
        data["success"] = this.success;
        data["firmwareId"] = this.firmwareId;
        data["execute"] = this.execute;
        super.toJSON(data);
        return data; 
    }
}

export interface IHardwareControllerFirmwareResponce extends IHardwareControllerResponceBase {
    version?: string | undefined;
    versionMajor: number;
    versionMinor: number;
    versionRevision: number;
    versionHash?: string | undefined;
    releaseTime: number;
    success: number;
    firmwareId: number;
    execute?: string | undefined;
}

export class SelectRequestBaseOfCanWriteFilter implements ISelectRequestBaseOfCanWriteFilter {
    filter: CanWriteFilter = new CanWriteFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfCanWriteFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? CanWriteFilter.fromJS(data["filter"]) : new CanWriteFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfCanWriteFilter {
        let result = new SelectRequestBaseOfCanWriteFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfCanWriteFilter {
    filter: CanWriteFilter;
    page: Paginator;
}

export class InstallationsSelectRequest extends SelectRequestBaseOfCanWriteFilter implements IInstallationsSelectRequest {

    constructor(data?: IInstallationsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): InstallationsSelectRequest {
        let result = new InstallationsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInstallationsSelectRequest extends ISelectRequestBaseOfCanWriteFilter {
}

export class SelectResponceBaseOfInstallationView implements ISelectResponceBaseOfInstallationView {
    data?: InstallationView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfInstallationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InstallationView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfInstallationView {
        let result = new SelectResponceBaseOfInstallationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfInstallationView {
    data?: InstallationView[] | undefined;
    total: number;
}

export class InstallationsSelectResponce extends SelectResponceBaseOfInstallationView implements IInstallationsSelectResponce {

    constructor(data?: IInstallationsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): InstallationsSelectResponce {
        let result = new InstallationsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInstallationsSelectResponce extends ISelectResponceBaseOfInstallationView {
}

/** Represents T:Jade.Api.Database.Installation view with referenced entity names */
export class InstallationView extends Installation implements IInstallationView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** References P:Jade.Api.Database.InstallationUser.IsInstallationOwner
This field is filled only with T:Jade.Api.Controllers.InstallationsController */
    installationUserIsInstallationOwner: boolean;
    /** References P:Jade.Api.Database.InstallationUser.IsInstallationAdministrator
This field is filled only with T:Jade.Api.Controllers.InstallationsController */
    installationUserIsInstallationAdministrator: boolean;

    constructor(data?: IInstallationView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationUserIsInstallationOwner = data["installationUserIsInstallationOwner"];
            this.installationUserIsInstallationAdministrator = data["installationUserIsInstallationAdministrator"];
        }
    }

    static fromJS(data: any): InstallationView {
        let result = new InstallationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationUserIsInstallationOwner"] = this.installationUserIsInstallationOwner;
        data["installationUserIsInstallationAdministrator"] = this.installationUserIsInstallationAdministrator;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Installation view with referenced entity names */
export interface IInstallationView extends IInstallation {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** References P:Jade.Api.Database.InstallationUser.IsInstallationOwner
This field is filled only with T:Jade.Api.Controllers.InstallationsController */
    installationUserIsInstallationOwner: boolean;
    /** References P:Jade.Api.Database.InstallationUser.IsInstallationAdministrator
This field is filled only with T:Jade.Api.Controllers.InstallationsController */
    installationUserIsInstallationAdministrator: boolean;
}

export class InstallationUsersSelectRequest extends SelectRequestBaseOfInstallationFilter implements IInstallationUsersSelectRequest {

    constructor(data?: IInstallationUsersSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): InstallationUsersSelectRequest {
        let result = new InstallationUsersSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInstallationUsersSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfInstallationUserView implements ISelectResponceBaseOfInstallationUserView {
    data?: InstallationUserView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfInstallationUserView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InstallationUserView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfInstallationUserView {
        let result = new SelectResponceBaseOfInstallationUserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfInstallationUserView {
    data?: InstallationUserView[] | undefined;
    total: number;
}

export class InstallationUsersSelectResponce extends SelectResponceBaseOfInstallationUserView implements IInstallationUsersSelectResponce {

    constructor(data?: IInstallationUsersSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): InstallationUsersSelectResponce {
        let result = new InstallationUsersSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInstallationUsersSelectResponce extends ISelectResponceBaseOfInstallationUserView {
}

export class ConfirmOrderRequest implements IConfirmOrderRequest {
    entries: OrderEntry[] = [];
    clientId: number;
    deviceId?: string | undefined;
    installationId: number;
    date: Date;

    constructor(data?: IConfirmOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(OrderEntry.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.deviceId = data["deviceId"];
            this.installationId = data["installationId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmOrderRequest {
        let result = new ConfirmOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["deviceId"] = this.deviceId;
        data["installationId"] = this.installationId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IConfirmOrderRequest {
    entries: OrderEntry[];
    clientId: number;
    deviceId?: string | undefined;
    installationId: number;
    date: Date;
}

export class OrderEntry implements IOrderEntry {
    rightTypeId: number;
    count: number;
    price: number;

    constructor(data?: IOrderEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rightTypeId = data["rightTypeId"];
            this.count = data["count"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): OrderEntry {
        let result = new OrderEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rightTypeId"] = this.rightTypeId;
        data["count"] = this.count;
        data["price"] = this.price;
        return data; 
    }
}

export interface IOrderEntry {
    rightTypeId: number;
    count: number;
    price: number;
}

export class SelectRequestBaseOfFilterBase implements ISelectRequestBaseOfFilterBase {
    filter: FilterBase = new FilterBase();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfFilterBase {
        let result = new SelectRequestBaseOfFilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfFilterBase {
    filter: FilterBase;
    page: Paginator;
}

export class GetCitiesRequest extends SelectRequestBaseOfFilterBase implements IGetCitiesRequest {

    constructor(data?: IGetCitiesRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetCitiesRequest {
        let result = new GetCitiesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetCitiesRequest extends ISelectRequestBaseOfFilterBase {
}

export class SelectResponceBaseOfCity implements ISelectResponceBaseOfCity {
    data?: City[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfCity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(City.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfCity {
        let result = new SelectResponceBaseOfCity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfCity {
    data?: City[] | undefined;
    total: number;
}

export class GetCitiesResponce extends SelectResponceBaseOfCity implements IGetCitiesResponce {

    constructor(data?: IGetCitiesResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetCitiesResponce {
        let result = new GetCitiesResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetCitiesResponce extends ISelectResponceBaseOfCity {
}

export class City implements ICity {
    id: number;
    name?: string | undefined;

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): City {
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICity {
    id: number;
    name?: string | undefined;
}

export class SelectRequestBaseOfInstallationsFilter implements ISelectRequestBaseOfInstallationsFilter {
    filter: InstallationsFilter = new InstallationsFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfInstallationsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? InstallationsFilter.fromJS(data["filter"]) : new InstallationsFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfInstallationsFilter {
        let result = new SelectRequestBaseOfInstallationsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfInstallationsFilter {
    filter: InstallationsFilter;
    page: Paginator;
}

export class GetInstallationsRequest extends SelectRequestBaseOfInstallationsFilter implements IGetInstallationsRequest {

    constructor(data?: IGetInstallationsRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetInstallationsRequest {
        let result = new GetInstallationsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetInstallationsRequest extends ISelectRequestBaseOfInstallationsFilter {
}

export class InstallationsFilter extends FilterBase implements IInstallationsFilter {
    cityId?: number | undefined;

    constructor(data?: IInstallationsFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cityId = data["cityId"];
        }
    }

    static fromJS(data: any): InstallationsFilter {
        let result = new InstallationsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInstallationsFilter extends IFilterBase {
    cityId?: number | undefined;
}

export class SelectResponceBaseOfInstallationInfo implements ISelectResponceBaseOfInstallationInfo {
    data?: InstallationInfo[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfInstallationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InstallationInfo.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfInstallationInfo {
        let result = new SelectResponceBaseOfInstallationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfInstallationInfo {
    data?: InstallationInfo[] | undefined;
    total: number;
}

export class GetInstallationsResponce extends SelectResponceBaseOfInstallationInfo implements IGetInstallationsResponce {

    constructor(data?: IGetInstallationsResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetInstallationsResponce {
        let result = new GetInstallationsResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetInstallationsResponce extends ISelectResponceBaseOfInstallationInfo {
}

export class InstallationInfo implements IInstallationInfo {
    id: number;
    cityId: number;
    name: string;
    description: string;
    allowTickets: boolean;
    allowAccount: boolean;

    constructor(data?: IInstallationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cityId = data["cityId"];
            this.name = data["name"];
            this.description = data["description"];
            this.allowTickets = data["allowTickets"];
            this.allowAccount = data["allowAccount"];
        }
    }

    static fromJS(data: any): InstallationInfo {
        let result = new InstallationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["allowTickets"] = this.allowTickets;
        data["allowAccount"] = this.allowAccount;
        return data; 
    }
}

export interface IInstallationInfo {
    id: number;
    cityId: number;
    name: string;
    description: string;
    allowTickets: boolean;
    allowAccount: boolean;
}

export class GetClientInfoResponce implements IGetClientInfoResponce {
    accounts?: AccountInfo[] | undefined;
    tickets?: TicketInfo[] | undefined;
    qrCode?: string | undefined;

    constructor(data?: IGetClientInfoResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accounts"] && data["accounts"].constructor === Array) {
                this.accounts = [];
                for (let item of data["accounts"])
                    this.accounts.push(AccountInfo.fromJS(item));
            }
            if (data["tickets"] && data["tickets"].constructor === Array) {
                this.tickets = [];
                for (let item of data["tickets"])
                    this.tickets.push(TicketInfo.fromJS(item));
            }
            this.qrCode = data["qrCode"];
        }
    }

    static fromJS(data: any): GetClientInfoResponce {
        let result = new GetClientInfoResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accounts && this.accounts.constructor === Array) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (this.tickets && this.tickets.constructor === Array) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        data["qrCode"] = this.qrCode;
        return data; 
    }
}

export interface IGetClientInfoResponce {
    accounts?: AccountInfo[] | undefined;
    tickets?: TicketInfo[] | undefined;
    qrCode?: string | undefined;
}

export class AccountInfo implements IAccountInfo {
    id: number;
    rightTypeId: number;
    amount: number;
    name?: string | undefined;
    currency?: string | undefined;
    order: number;

    constructor(data?: IAccountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rightTypeId = data["rightTypeId"];
            this.amount = data["amount"];
            this.name = data["name"];
            this.currency = data["currency"];
            this.order = data["order"];
        }
    }

    static fromJS(data: any): AccountInfo {
        let result = new AccountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rightTypeId"] = this.rightTypeId;
        data["amount"] = this.amount;
        data["name"] = this.name;
        data["currency"] = this.currency;
        data["order"] = this.order;
        return data; 
    }
}

export interface IAccountInfo {
    id: number;
    rightTypeId: number;
    amount: number;
    name?: string | undefined;
    currency?: string | undefined;
    order: number;
}

export class TicketInfo implements ITicketInfo {
    amount: number;
    name?: string | undefined;
    from: Date;
    to: Date;
    id: number;
    rightTypeId: number;

    constructor(data?: ITicketInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.name = data["name"];
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.id = data["id"];
            this.rightTypeId = data["rightTypeId"];
        }
    }

    static fromJS(data: any): TicketInfo {
        let result = new TicketInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["name"] = this.name;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["rightTypeId"] = this.rightTypeId;
        return data; 
    }
}

export interface ITicketInfo {
    amount: number;
    name?: string | undefined;
    from: Date;
    to: Date;
    id: number;
    rightTypeId: number;
}

export class SelectRequestBaseOfServiciesFilter implements ISelectRequestBaseOfServiciesFilter {
    filter: ServiciesFilter = new ServiciesFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfServiciesFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? ServiciesFilter.fromJS(data["filter"]) : new ServiciesFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfServiciesFilter {
        let result = new SelectRequestBaseOfServiciesFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfServiciesFilter {
    filter: ServiciesFilter;
    page: Paginator;
}

export class GetServiciesRequest extends SelectRequestBaseOfServiciesFilter implements IGetServiciesRequest {

    constructor(data?: IGetServiciesRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetServiciesRequest {
        let result = new GetServiciesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetServiciesRequest extends ISelectRequestBaseOfServiciesFilter {
}

export class ServiciesFilter extends FilterBase implements IServiciesFilter {
    installationId: number;

    constructor(data?: IServiciesFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.installationId = data["installationId"];
        }
    }

    static fromJS(data: any): ServiciesFilter {
        let result = new ServiciesFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationId"] = this.installationId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiciesFilter extends IFilterBase {
    installationId: number;
}

export class SelectResponceBaseOfServiceInfo implements ISelectResponceBaseOfServiceInfo {
    data?: ServiceInfo[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfServiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ServiceInfo.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfServiceInfo {
        let result = new SelectResponceBaseOfServiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfServiceInfo {
    data?: ServiceInfo[] | undefined;
    total: number;
}

export class GetServiciesResponce extends SelectResponceBaseOfServiceInfo implements IGetServiciesResponce {

    constructor(data?: IGetServiciesResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): GetServiciesResponce {
        let result = new GetServiciesResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IGetServiciesResponce extends ISelectResponceBaseOfServiceInfo {
}

export class ServiceInfo implements IServiceInfo {
    id: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IServiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): ServiceInfo {
        let result = new ServiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IServiceInfo {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class ServiceOperation implements IServiceOperation {
    time: Date;
    serviceName?: string | undefined;
    amount: number;
    payName?: string | undefined;

    constructor(data?: IServiceOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.serviceName = data["serviceName"];
            this.amount = data["amount"];
            this.payName = data["payName"];
        }
    }

    static fromJS(data: any): ServiceOperation {
        let result = new ServiceOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["serviceName"] = this.serviceName;
        data["amount"] = this.amount;
        data["payName"] = this.payName;
        return data; 
    }
}

export interface IServiceOperation {
    time: Date;
    serviceName?: string | undefined;
    amount: number;
    payName?: string | undefined;
}

export class BuyOperation implements IBuyOperation {
    time: Date;
    amount: number;
    name?: string | undefined;

    constructor(data?: IBuyOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BuyOperation {
        let result = new BuyOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBuyOperation {
    time: Date;
    amount: number;
    name?: string | undefined;
}

export class ServiceTicket implements IServiceTicket {
    name?: string | undefined;
    price: number;
    rightTypeId: number;

    constructor(data?: IServiceTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.price = data["price"];
            this.rightTypeId = data["rightTypeId"];
        }
    }

    static fromJS(data: any): ServiceTicket {
        let result = new ServiceTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["rightTypeId"] = this.rightTypeId;
        return data; 
    }
}

export interface IServiceTicket {
    name?: string | undefined;
    price: number;
    rightTypeId: number;
}

export class AccountType implements IAccountType {
    rightTypeId: number;
    name?: string | undefined;

    constructor(data?: IAccountType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rightTypeId = data["rightTypeId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AccountType {
        let result = new AccountType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rightTypeId"] = this.rightTypeId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAccountType {
    rightTypeId: number;
    name?: string | undefined;
}

export class ServicePoint implements IServicePoint {
    id: number;
    name: string;
    installationId?: number | undefined;
    guid: string;
    authorized: boolean;
    type: ServicePointType;
    controllerType?: ControllerType | undefined;
    secret?: string | undefined;
    timeZone?: number | undefined;
    refreshTime: number;
    registerTime: Date;
    lastGetSettingsTime?: Date | undefined;
    lastGetTariffTime?: Date | undefined;
    lastUploadGeneralLogTime?: Date | undefined;
    lastUploadPassLogTime?: Date | undefined;
    lastUploadTransactionLogTime?: Date | undefined;
    allowOnlineCheckPass: boolean;
    allowSoftOffline: boolean;
    onlineRequestTimeout: number;
    pulseTime?: number | undefined;

    constructor(data?: IServicePoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.installationId = data["installationId"];
            this.guid = data["guid"];
            this.authorized = data["authorized"];
            this.type = data["type"];
            this.controllerType = data["controllerType"];
            this.secret = data["secret"];
            this.timeZone = data["timeZone"];
            this.refreshTime = data["refreshTime"];
            this.registerTime = data["registerTime"] ? new Date(data["registerTime"].toString()) : <any>undefined;
            this.lastGetSettingsTime = data["lastGetSettingsTime"] ? new Date(data["lastGetSettingsTime"].toString()) : <any>undefined;
            this.lastGetTariffTime = data["lastGetTariffTime"] ? new Date(data["lastGetTariffTime"].toString()) : <any>undefined;
            this.lastUploadGeneralLogTime = data["lastUploadGeneralLogTime"] ? new Date(data["lastUploadGeneralLogTime"].toString()) : <any>undefined;
            this.lastUploadPassLogTime = data["lastUploadPassLogTime"] ? new Date(data["lastUploadPassLogTime"].toString()) : <any>undefined;
            this.lastUploadTransactionLogTime = data["lastUploadTransactionLogTime"] ? new Date(data["lastUploadTransactionLogTime"].toString()) : <any>undefined;
            this.allowOnlineCheckPass = data["allowOnlineCheckPass"];
            this.allowSoftOffline = data["allowSoftOffline"];
            this.onlineRequestTimeout = data["onlineRequestTimeout"];
            this.pulseTime = data["pulseTime"];
        }
    }

    static fromJS(data: any): ServicePoint {
        let result = new ServicePoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        data["guid"] = this.guid;
        data["authorized"] = this.authorized;
        data["type"] = this.type;
        data["controllerType"] = this.controllerType;
        data["secret"] = this.secret;
        data["timeZone"] = this.timeZone;
        data["refreshTime"] = this.refreshTime;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["lastGetSettingsTime"] = this.lastGetSettingsTime ? this.lastGetSettingsTime.toISOString() : <any>undefined;
        data["lastGetTariffTime"] = this.lastGetTariffTime ? this.lastGetTariffTime.toISOString() : <any>undefined;
        data["lastUploadGeneralLogTime"] = this.lastUploadGeneralLogTime ? this.lastUploadGeneralLogTime.toISOString() : <any>undefined;
        data["lastUploadPassLogTime"] = this.lastUploadPassLogTime ? this.lastUploadPassLogTime.toISOString() : <any>undefined;
        data["lastUploadTransactionLogTime"] = this.lastUploadTransactionLogTime ? this.lastUploadTransactionLogTime.toISOString() : <any>undefined;
        data["allowOnlineCheckPass"] = this.allowOnlineCheckPass;
        data["allowSoftOffline"] = this.allowSoftOffline;
        data["onlineRequestTimeout"] = this.onlineRequestTimeout;
        data["pulseTime"] = this.pulseTime;
        return data; 
    }
}

export interface IServicePoint {
    id: number;
    name: string;
    installationId?: number | undefined;
    guid: string;
    authorized: boolean;
    type: ServicePointType;
    controllerType?: ControllerType | undefined;
    secret?: string | undefined;
    timeZone?: number | undefined;
    refreshTime: number;
    registerTime: Date;
    lastGetSettingsTime?: Date | undefined;
    lastGetTariffTime?: Date | undefined;
    lastUploadGeneralLogTime?: Date | undefined;
    lastUploadPassLogTime?: Date | undefined;
    lastUploadTransactionLogTime?: Date | undefined;
    allowOnlineCheckPass: boolean;
    allowSoftOffline: boolean;
    onlineRequestTimeout: number;
    pulseTime?: number | undefined;
}

export enum ServicePointType {
    Controller = 0, 
    Mobile = 1, 
}

export enum ControllerType {
    Arduino = 0, 
    CardLan = 1, 
}

export class Service implements IService {
    id: number;
    name: string;
    organizationId: number;
    delay: number;
    denyQrCode: boolean;

    constructor(data?: IService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.organizationId = data["organizationId"];
            this.delay = data["delay"];
            this.denyQrCode = data["denyQrCode"];
        }
    }

    static fromJS(data: any): Service {
        let result = new Service();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["delay"] = this.delay;
        data["denyQrCode"] = this.denyQrCode;
        return data; 
    }
}

export interface IService {
    id: number;
    name: string;
    organizationId: number;
    delay: number;
    denyQrCode: boolean;
}

export enum Direction {
    Entrance = 0, 
    Exit = 1, 
}

export enum CardType {
    MiFareClassic = 0, 
    QrCode = 1, 
}

export class ValidatePassResponce implements IValidatePassResponce {
    /** Ticket owner's information. Null if there are no information */
    user?: UserData | undefined;
    /** Ticket owner's photo url. Empty if there are no photo */
    photoUrl?: string | undefined;
    /** Message to display */
    message: string;
    /** Pass is allowed */
    success: boolean;

    constructor(data?: IValidatePassResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserData.fromJS(data["user"]) : <any>undefined;
            this.photoUrl = data["photoUrl"];
            this.message = data["message"];
            this.success = data["success"];
        }
    }

    static fromJS(data: any): ValidatePassResponce {
        let result = new ValidatePassResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["photoUrl"] = this.photoUrl;
        data["message"] = this.message;
        data["success"] = this.success;
        return data; 
    }
}

export interface IValidatePassResponce {
    /** Ticket owner's information. Null if there are no information */
    user?: UserData | undefined;
    /** Ticket owner's photo url. Empty if there are no photo */
    photoUrl?: string | undefined;
    /** Message to display */
    message: string;
    /** Pass is allowed */
    success: boolean;
}

export class Organization implements IOrganization {
    id: number;
    name: string;
    description?: string | undefined;
    installationId: number;
    inn?: string | undefined;
    isMainOrganization: boolean;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.installationId = data["installationId"];
            this.inn = data["inn"];
            this.isMainOrganization = data["isMainOrganization"];
        }
    }

    static fromJS(data: any): Organization {
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["installationId"] = this.installationId;
        data["inn"] = this.inn;
        data["isMainOrganization"] = this.isMainOrganization;
        return data; 
    }
}

export interface IOrganization {
    id: number;
    name: string;
    description?: string | undefined;
    installationId: number;
    inn?: string | undefined;
    isMainOrganization: boolean;
}

export class OrganizationsSelectRequest extends SelectRequestBaseOfInstallationFilter implements IOrganizationsSelectRequest {

    constructor(data?: IOrganizationsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OrganizationsSelectRequest {
        let result = new OrganizationsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOrganizationsSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfOrganizationView implements ISelectResponceBaseOfOrganizationView {
    data?: OrganizationView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfOrganizationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(OrganizationView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfOrganizationView {
        let result = new SelectResponceBaseOfOrganizationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfOrganizationView {
    data?: OrganizationView[] | undefined;
    total: number;
}

export class OrganizationsSelectResponce extends SelectResponceBaseOfOrganizationView implements IOrganizationsSelectResponce {

    constructor(data?: IOrganizationsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OrganizationsSelectResponce {
        let result = new OrganizationsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOrganizationsSelectResponce extends ISelectResponceBaseOfOrganizationView {
}

/** Represents T:Jade.Api.Database.Organization view with referenced entity names */
export class OrganizationView extends Organization implements IOrganizationView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Organization.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IOrganizationView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): OrganizationView {
        let result = new OrganizationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Organization view with referenced entity names */
export interface IOrganizationView extends IOrganization {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Organization.InstallationId */
    installationName?: string | undefined;
}

export class OrganizationUsersSelectRequest extends SelectRequestBaseOfInstallationFilter implements IOrganizationUsersSelectRequest {

    constructor(data?: IOrganizationUsersSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OrganizationUsersSelectRequest {
        let result = new OrganizationUsersSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOrganizationUsersSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfOrganizationUserView implements ISelectResponceBaseOfOrganizationUserView {
    data?: OrganizationUserView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfOrganizationUserView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(OrganizationUserView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfOrganizationUserView {
        let result = new SelectResponceBaseOfOrganizationUserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfOrganizationUserView {
    data?: OrganizationUserView[] | undefined;
    total: number;
}

export class OrganizationUsersSelectResponce extends SelectResponceBaseOfOrganizationUserView implements IOrganizationUsersSelectResponce {

    constructor(data?: IOrganizationUsersSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OrganizationUsersSelectResponce {
        let result = new OrganizationUsersSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOrganizationUsersSelectResponce extends ISelectResponceBaseOfOrganizationUserView {
}

export class CashdeskAcquiringDriver implements ICashdeskAcquiringDriver {
    id: number;
    name: string;

    constructor(data?: ICashdeskAcquiringDriver) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CashdeskAcquiringDriver {
        let result = new CashdeskAcquiringDriver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICashdeskAcquiringDriver {
    id: number;
    name: string;
}

export class ProcessingsSelectRequest extends SelectRequestBaseOfInstallationFilter implements IProcessingsSelectRequest {

    constructor(data?: IProcessingsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ProcessingsSelectRequest {
        let result = new ProcessingsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IProcessingsSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfProcessingView implements ISelectResponceBaseOfProcessingView {
    data?: ProcessingView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfProcessingView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ProcessingView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfProcessingView {
        let result = new SelectResponceBaseOfProcessingView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfProcessingView {
    data?: ProcessingView[] | undefined;
    total: number;
}

export class ProcessingsSelectResponce extends SelectResponceBaseOfProcessingView implements IProcessingsSelectResponce {

    constructor(data?: IProcessingsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ProcessingsSelectResponce {
        let result = new ProcessingsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IProcessingsSelectResponce extends ISelectResponceBaseOfProcessingView {
}

/** Represents T:Jade.Api.Database.Processing view with referenced entity names */
export class ProcessingView extends Processing implements IProcessingView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.Processing.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Processing.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IProcessingView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.goodTypeName = data["goodTypeName"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): ProcessingView {
        let result = new ProcessingView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["goodTypeName"] = this.goodTypeName;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Processing view with referenced entity names */
export interface IProcessingView extends IProcessing {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.Processing.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Processing.InstallationId */
    installationName?: string | undefined;
}

/** Base class for all report data */
export class ReportLineBase implements IReportLineBase {
    installationId: number;
    /** Installation name */
    installationName?: string | undefined;

    constructor(data?: IReportLineBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.installationId = data["installationId"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): ReportLineBase {
        let result = new ReportLineBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationId"] = this.installationId;
        data["installationName"] = this.installationName;
        return data; 
    }
}

/** Base class for all report data */
export interface IReportLineBase {
    installationId: number;
    /** Installation name */
    installationName?: string | undefined;
}

/** Base class for reports grouped by cashdesk */
export class CashdeskReportLineBase extends ReportLineBase implements ICashdeskReportLineBase {
    cashdeskId: number;
    /** Sell/Return cashdesk name
             */
    cashdeskName?: string | undefined;

    constructor(data?: ICashdeskReportLineBase) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cashdeskId = data["cashdeskId"];
            this.cashdeskName = data["cashdeskName"];
        }
    }

    static fromJS(data: any): CashdeskReportLineBase {
        let result = new CashdeskReportLineBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashdeskId"] = this.cashdeskId;
        data["cashdeskName"] = this.cashdeskName;
        super.toJSON(data);
        return data; 
    }
}

/** Base class for reports grouped by cashdesk */
export interface ICashdeskReportLineBase extends IReportLineBase {
    cashdeskId: number;
    /** Sell/Return cashdesk name
             */
    cashdeskName?: string | undefined;
}

export class CashdeskTotalsReportLine extends CashdeskReportLineBase implements ICashdeskTotalsReportLine {
    /** Sells amount */
    amount: number;
    /** Good Id */
    goodTypeId: number;
    /** Good name */
    goodTypeName?: string | undefined;
    /** This record is good return */
    isReturn: boolean;
    /** Good quantity */
    quantity: number;
    /** Good category (folder) name */
    categoryName?: string | undefined;

    constructor(data?: ICashdeskTotalsReportLine) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.amount = data["amount"];
            this.goodTypeId = data["goodTypeId"];
            this.goodTypeName = data["goodTypeName"];
            this.isReturn = data["isReturn"];
            this.quantity = data["quantity"];
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): CashdeskTotalsReportLine {
        let result = new CashdeskTotalsReportLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["goodTypeId"] = this.goodTypeId;
        data["goodTypeName"] = this.goodTypeName;
        data["isReturn"] = this.isReturn;
        data["quantity"] = this.quantity;
        data["categoryName"] = this.categoryName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdeskTotalsReportLine extends ICashdeskReportLineBase {
    /** Sells amount */
    amount: number;
    /** Good Id */
    goodTypeId: number;
    /** Good name */
    goodTypeName?: string | undefined;
    /** This record is good return */
    isReturn: boolean;
    /** Good quantity */
    quantity: number;
    /** Good category (folder) name */
    categoryName?: string | undefined;
}

export class CashdeskPayTotalsXReportLine extends CashdeskReportLineBase implements ICashdeskPayTotalsXReportLine {
    /** Processing Id
             */
    processingId: number;
    /** Processing name
             */
    processingName?: string | undefined;
    /** Payment type
             */
    paymentType: PaymentType;
    /** Totals
             */
    amount: number;
    /** Date
             */
    date: Date;
    /** Determines if operation grouped by type
 null - not grouped true - return false - sell */
    isReturn?: boolean | undefined;
    /** Returns caption */
    isReturnCaption?: string | undefined;
    /** Payment type caption */
    paymentTypeCaption?: string | undefined;

    constructor(data?: ICashdeskPayTotalsXReportLine) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.processingId = data["processingId"];
            this.processingName = data["processingName"];
            this.paymentType = data["paymentType"];
            this.amount = data["amount"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.isReturn = data["isReturn"];
            this.isReturnCaption = data["isReturnCaption"];
            this.paymentTypeCaption = data["paymentTypeCaption"];
        }
    }

    static fromJS(data: any): CashdeskPayTotalsXReportLine {
        let result = new CashdeskPayTotalsXReportLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processingId"] = this.processingId;
        data["processingName"] = this.processingName;
        data["paymentType"] = this.paymentType;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["isReturn"] = this.isReturn;
        data["isReturnCaption"] = this.isReturnCaption;
        data["paymentTypeCaption"] = this.paymentTypeCaption;
        super.toJSON(data);
        return data; 
    }
}

export interface ICashdeskPayTotalsXReportLine extends ICashdeskReportLineBase {
    /** Processing Id
             */
    processingId: number;
    /** Processing name
             */
    processingName?: string | undefined;
    /** Payment type
             */
    paymentType: PaymentType;
    /** Totals
             */
    amount: number;
    /** Date
             */
    date: Date;
    /** Determines if operation grouped by type
 null - not grouped true - return false - sell */
    isReturn?: boolean | undefined;
    /** Returns caption */
    isReturnCaption?: string | undefined;
    /** Payment type caption */
    paymentTypeCaption?: string | undefined;
}

export class ServicePointServiceBound implements IServicePointServiceBound {
    servicePointId: number;
    serviceId: number;
    serviceName?: string | undefined;
    isSet: boolean;
    organizationName?: string | undefined;
    denyQrCode: boolean;

    constructor(data?: IServicePointServiceBound) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.servicePointId = data["servicePointId"];
            this.serviceId = data["serviceId"];
            this.serviceName = data["serviceName"];
            this.isSet = data["isSet"];
            this.organizationName = data["organizationName"];
            this.denyQrCode = data["denyQrCode"];
        }
    }

    static fromJS(data: any): ServicePointServiceBound {
        let result = new ServicePointServiceBound();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["servicePointId"] = this.servicePointId;
        data["serviceId"] = this.serviceId;
        data["serviceName"] = this.serviceName;
        data["isSet"] = this.isSet;
        data["organizationName"] = this.organizationName;
        data["denyQrCode"] = this.denyQrCode;
        return data; 
    }
}

export interface IServicePointServiceBound {
    servicePointId: number;
    serviceId: number;
    serviceName?: string | undefined;
    isSet: boolean;
    organizationName?: string | undefined;
    denyQrCode: boolean;
}

export class ServicePointsSelectRequest extends SelectRequestBaseOfCanWriteFilter implements IServicePointsSelectRequest {

    constructor(data?: IServicePointsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServicePointsSelectRequest {
        let result = new ServicePointsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServicePointsSelectRequest extends ISelectRequestBaseOfCanWriteFilter {
}

export class SelectResponceBaseOfServicePointView implements ISelectResponceBaseOfServicePointView {
    data?: ServicePointView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfServicePointView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ServicePointView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfServicePointView {
        let result = new SelectResponceBaseOfServicePointView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfServicePointView {
    data?: ServicePointView[] | undefined;
    total: number;
}

export class ServicePointsSelectResponce extends SelectResponceBaseOfServicePointView implements IServicePointsSelectResponce {

    constructor(data?: IServicePointsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServicePointsSelectResponce {
        let result = new ServicePointsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServicePointsSelectResponce extends ISelectResponceBaseOfServicePointView {
}

/** Represents T:Jade.Api.Database.ServicePoint view with referenced entity names */
export class ServicePointView extends ServicePoint implements IServicePointView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.ServicePoint.InstallationId */
    installationName?: string | undefined;

    constructor(data?: IServicePointView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): ServicePointView {
        let result = new ServicePointView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.ServicePoint view with referenced entity names */
export interface IServicePointView extends IServicePoint {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.ServicePoint.InstallationId */
    installationName?: string | undefined;
}

export class SelectRequestBaseOfServiceTariffFilter implements ISelectRequestBaseOfServiceTariffFilter {
    filter: ServiceTariffFilter = new ServiceTariffFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfServiceTariffFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? ServiceTariffFilter.fromJS(data["filter"]) : new ServiceTariffFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfServiceTariffFilter {
        let result = new SelectRequestBaseOfServiceTariffFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfServiceTariffFilter {
    filter: ServiceTariffFilter;
    page: Paginator;
}

export class ServiceTariffRequest extends SelectRequestBaseOfServiceTariffFilter implements IServiceTariffRequest {

    constructor(data?: IServiceTariffRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServiceTariffRequest {
        let result = new ServiceTariffRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceTariffRequest extends ISelectRequestBaseOfServiceTariffFilter {
}

export class ServiceTariffFilter extends CanWriteFilter implements IServiceTariffFilter {
    serviceId: number;

    constructor(data?: IServiceTariffFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceId = data["serviceId"];
        }
    }

    static fromJS(data: any): ServiceTariffFilter {
        let result = new ServiceTariffFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceTariffFilter extends ICanWriteFilter {
    serviceId: number;
}

export class SelectResponceBaseOfServiceTariffView implements ISelectResponceBaseOfServiceTariffView {
    data?: ServiceTariffView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfServiceTariffView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ServiceTariffView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfServiceTariffView {
        let result = new SelectResponceBaseOfServiceTariffView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfServiceTariffView {
    data?: ServiceTariffView[] | undefined;
    total: number;
}

export class ServiceTariffResponce extends SelectResponceBaseOfServiceTariffView implements IServiceTariffResponce {

    constructor(data?: IServiceTariffResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServiceTariffResponce {
        let result = new ServiceTariffResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceTariffResponce extends ISelectResponceBaseOfServiceTariffView {
}

export class ServiceTariff implements IServiceTariff {
    id: number;
    rightTypeId: number;
    serviceId: number;
    from: Date;
    to: Date;
    amount: number;

    constructor(data?: IServiceTariff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rightTypeId = data["rightTypeId"];
            this.serviceId = data["serviceId"];
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): ServiceTariff {
        let result = new ServiceTariff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rightTypeId"] = this.rightTypeId;
        data["serviceId"] = this.serviceId;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IServiceTariff {
    id: number;
    rightTypeId: number;
    serviceId: number;
    from: Date;
    to: Date;
    amount: number;
}

/** Represents T:Jade.Api.Database.ServiceTariff view with referenced entity names */
export class ServiceTariffView extends ServiceTariff implements IServiceTariffView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Service.Name of T:Jade.Api.Database.Service referenced by P:Jade.Api.Database.ServiceTariff.ServiceId */
    serviceName?: string | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.ServiceTariff.RightTypeId */
    rightTypeName?: string | undefined;

    constructor(data?: IServiceTariffView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.serviceName = data["serviceName"];
            this.rightTypeName = data["rightTypeName"];
        }
    }

    static fromJS(data: any): ServiceTariffView {
        let result = new ServiceTariffView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["serviceName"] = this.serviceName;
        data["rightTypeName"] = this.rightTypeName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.ServiceTariff view with referenced entity names */
export interface IServiceTariffView extends IServiceTariff {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Service.Name of T:Jade.Api.Database.Service referenced by P:Jade.Api.Database.ServiceTariff.ServiceId */
    serviceName?: string | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.ServiceTariff.RightTypeId */
    rightTypeName?: string | undefined;
}

export class ServicesSelectRequest extends SelectRequestBaseOfCanWriteFilter implements IServicesSelectRequest {

    constructor(data?: IServicesSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServicesSelectRequest {
        let result = new ServicesSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServicesSelectRequest extends ISelectRequestBaseOfCanWriteFilter {
}

export class SelectResponceBaseOfServiceView implements ISelectResponceBaseOfServiceView {
    data?: ServiceView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfServiceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ServiceView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfServiceView {
        let result = new SelectResponceBaseOfServiceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfServiceView {
    data?: ServiceView[] | undefined;
    total: number;
}

export class ServicesSelectResponce extends SelectResponceBaseOfServiceView implements IServicesSelectResponce {

    constructor(data?: IServicesSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServicesSelectResponce {
        let result = new ServicesSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServicesSelectResponce extends ISelectResponceBaseOfServiceView {
}

/** Represents T:Jade.Api.Database.Service view with referenced entity names */
export class ServiceView extends Service implements IServiceView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.Service.OrganizationId */
    organizationName?: string | undefined;

    constructor(data?: IServiceView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.organizationName = data["organizationName"];
        }
    }

    static fromJS(data: any): ServiceView {
        let result = new ServiceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["organizationName"] = this.organizationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Service view with referenced entity names */
export interface IServiceView extends IService {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.Service.OrganizationId */
    organizationName?: string | undefined;
}

export class ServiceTariffModifier implements IServiceTariffModifier {
    id: number;
    serviceId: number;
    name: string;
    validityDateFrom: Date;
    validityDateTo: Date;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    goodTypeId: number;
    priceType: PriceType;
    priceValue: number;
    calendarId?: number | undefined;
    dayTypeId?: number | undefined;
    dayOfWeek?: DayOfWeek | undefined;

    constructor(data?: IServiceTariffModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.serviceId = data["serviceId"];
            this.name = data["name"];
            this.validityDateFrom = data["validityDateFrom"] ? new Date(data["validityDateFrom"].toString()) : <any>undefined;
            this.validityDateTo = data["validityDateTo"] ? new Date(data["validityDateTo"].toString()) : <any>undefined;
            this.timeFrom = data["timeFrom"];
            this.timeTo = data["timeTo"];
            this.goodTypeId = data["goodTypeId"];
            this.priceType = data["priceType"];
            this.priceValue = data["priceValue"];
            this.calendarId = data["calendarId"];
            this.dayTypeId = data["dayTypeId"];
            this.dayOfWeek = data["dayOfWeek"];
        }
    }

    static fromJS(data: any): ServiceTariffModifier {
        let result = new ServiceTariffModifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceId"] = this.serviceId;
        data["name"] = this.name;
        data["validityDateFrom"] = this.validityDateFrom ? this.validityDateFrom.toISOString() : <any>undefined;
        data["validityDateTo"] = this.validityDateTo ? this.validityDateTo.toISOString() : <any>undefined;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["goodTypeId"] = this.goodTypeId;
        data["priceType"] = this.priceType;
        data["priceValue"] = this.priceValue;
        data["calendarId"] = this.calendarId;
        data["dayTypeId"] = this.dayTypeId;
        data["dayOfWeek"] = this.dayOfWeek;
        return data; 
    }
}

export interface IServiceTariffModifier {
    id: number;
    serviceId: number;
    name: string;
    validityDateFrom: Date;
    validityDateTo: Date;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    goodTypeId: number;
    priceType: PriceType;
    priceValue: number;
    calendarId?: number | undefined;
    dayTypeId?: number | undefined;
    dayOfWeek?: DayOfWeek | undefined;
}

export class ServiceTariffModifiersSelectRequest extends SelectRequestBaseOfServiceTariffFilter implements IServiceTariffModifiersSelectRequest {

    constructor(data?: IServiceTariffModifiersSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServiceTariffModifiersSelectRequest {
        let result = new ServiceTariffModifiersSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceTariffModifiersSelectRequest extends ISelectRequestBaseOfServiceTariffFilter {
}

export class SelectResponceBaseOfServiceTariffModifierView implements ISelectResponceBaseOfServiceTariffModifierView {
    data?: ServiceTariffModifierView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfServiceTariffModifierView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ServiceTariffModifierView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfServiceTariffModifierView {
        let result = new SelectResponceBaseOfServiceTariffModifierView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfServiceTariffModifierView {
    data?: ServiceTariffModifierView[] | undefined;
    total: number;
}

export class ServiceTariffModifiersSelectResponce extends SelectResponceBaseOfServiceTariffModifierView implements IServiceTariffModifiersSelectResponce {

    constructor(data?: IServiceTariffModifiersSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ServiceTariffModifiersSelectResponce {
        let result = new ServiceTariffModifiersSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceTariffModifiersSelectResponce extends ISelectResponceBaseOfServiceTariffModifierView {
}

/** Represents T:Jade.Api.Database.ServiceTariffModifier view with referenced entity names */
export class ServiceTariffModifierView extends ServiceTariffModifier implements IServiceTariffModifierView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.ServiceTariffModifier.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.ServiceTariffModifier.DayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Calendar.Name of T:Jade.Api.Database.Calendar referenced by P:Jade.Api.Database.ServiceTariffModifier.CalendarId */
    calendarName?: string | undefined;
    /** Represents P:Jade.Api.Database.Service.Name of T:Jade.Api.Database.Service referenced by P:Jade.Api.Database.ServiceTariffModifier.ServiceId */
    serviceName?: string | undefined;

    constructor(data?: IServiceTariffModifierView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.goodTypeName = data["goodTypeName"];
            this.dayTypeName = data["dayTypeName"];
            this.calendarName = data["calendarName"];
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): ServiceTariffModifierView {
        let result = new ServiceTariffModifierView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["goodTypeName"] = this.goodTypeName;
        data["dayTypeName"] = this.dayTypeName;
        data["calendarName"] = this.calendarName;
        data["serviceName"] = this.serviceName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.ServiceTariffModifier view with referenced entity names */
export interface IServiceTariffModifierView extends IServiceTariffModifier {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.ServiceTariffModifier.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.ServiceTariffModifier.DayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Calendar.Name of T:Jade.Api.Database.Calendar referenced by P:Jade.Api.Database.ServiceTariffModifier.CalendarId */
    calendarName?: string | undefined;
    /** Represents P:Jade.Api.Database.Service.Name of T:Jade.Api.Database.Service referenced by P:Jade.Api.Database.ServiceTariffModifier.ServiceId */
    serviceName?: string | undefined;
}

export class Spicies implements ISpicies {
    curry?: string | undefined;
    rosemary?: string | undefined;
    basil?: string | undefined;
    thyme?: string | undefined;

    constructor(data?: ISpicies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.curry = data["curry"];
            this.rosemary = data["rosemary"];
            this.basil = data["basil"];
            this.thyme = data["thyme"];
        }
    }

    static fromJS(data: any): Spicies {
        let result = new Spicies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["curry"] = this.curry;
        data["rosemary"] = this.rosemary;
        data["basil"] = this.basil;
        data["thyme"] = this.thyme;
        return data; 
    }
}

export interface ISpicies {
    curry?: string | undefined;
    rosemary?: string | undefined;
    basil?: string | undefined;
    thyme?: string | undefined;
}

export class TariffsSelectRequest extends SelectRequestBaseOfInstallationFilter implements ITariffsSelectRequest {

    constructor(data?: ITariffsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TariffsSelectRequest {
        let result = new TariffsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITariffsSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfTariffView implements ISelectResponceBaseOfTariffView {
    data?: TariffView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfTariffView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TariffView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfTariffView {
        let result = new SelectResponceBaseOfTariffView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfTariffView {
    data?: TariffView[] | undefined;
    total: number;
}

export class TariffsSelectResponce extends SelectResponceBaseOfTariffView implements ITariffsSelectResponce {

    constructor(data?: ITariffsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TariffsSelectResponce {
        let result = new TariffsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITariffsSelectResponce extends ISelectResponceBaseOfTariffView {
}

/** Represents T:Jade.Api.Database.Tariff view with referenced entity names */
export class TariffView extends Tariff implements ITariffView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Calendar.Name of T:Jade.Api.Database.Calendar referenced by P:Jade.Api.Database.Tariff.CalendarId */
    calendarName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.Tariff.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.Tariff.DayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.Tariff.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Tariff.InstallationId */
    installationName?: string | undefined;

    constructor(data?: ITariffView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.calendarName = data["calendarName"];
            this.organizationName = data["organizationName"];
            this.dayTypeName = data["dayTypeName"];
            this.goodTypeName = data["goodTypeName"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): TariffView {
        let result = new TariffView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["calendarName"] = this.calendarName;
        data["organizationName"] = this.organizationName;
        data["dayTypeName"] = this.dayTypeName;
        data["goodTypeName"] = this.goodTypeName;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.Tariff view with referenced entity names */
export interface ITariffView extends ITariff {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Calendar.Name of T:Jade.Api.Database.Calendar referenced by P:Jade.Api.Database.Tariff.CalendarId */
    calendarName?: string | undefined;
    /** Represents P:Jade.Api.Database.Organization.Name of T:Jade.Api.Database.Organization referenced by P:Jade.Api.Database.Tariff.OrganizationId */
    organizationName?: string | undefined;
    /** Represents P:Jade.Api.Database.DayType.Name of T:Jade.Api.Database.DayType referenced by P:Jade.Api.Database.Tariff.DayTypeId */
    dayTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.GoodType.Name of T:Jade.Api.Database.GoodType referenced by P:Jade.Api.Database.Tariff.GoodTypeId */
    goodTypeName?: string | undefined;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.Tariff.InstallationId */
    installationName?: string | undefined;
}

export class TimeLimitation implements ITimeLimitation {
    id: number;
    name: string;
    installationId: number;
    type: TimeLimitationType;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    period?: number | undefined;
    dayRoundingType?: RoundingType | undefined;
    weekRoundingType?: RoundingType | undefined;
    mounthRoundingType?: RoundingType | undefined;

    constructor(data?: ITimeLimitation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.installationId = data["installationId"];
            this.type = data["type"];
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>undefined;
            this.timeFrom = data["timeFrom"];
            this.timeTo = data["timeTo"];
            this.period = data["period"];
            this.dayRoundingType = data["dayRoundingType"];
            this.weekRoundingType = data["weekRoundingType"];
            this.mounthRoundingType = data["mounthRoundingType"];
        }
    }

    static fromJS(data: any): TimeLimitation {
        let result = new TimeLimitation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["installationId"] = this.installationId;
        data["type"] = this.type;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["period"] = this.period;
        data["dayRoundingType"] = this.dayRoundingType;
        data["weekRoundingType"] = this.weekRoundingType;
        data["mounthRoundingType"] = this.mounthRoundingType;
        return data; 
    }
}

export interface ITimeLimitation {
    id: number;
    name: string;
    installationId: number;
    type: TimeLimitationType;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    timeFrom?: string | undefined;
    timeTo?: string | undefined;
    period?: number | undefined;
    dayRoundingType?: RoundingType | undefined;
    weekRoundingType?: RoundingType | undefined;
    mounthRoundingType?: RoundingType | undefined;
}

export enum TimeLimitationType {
    FixedDate = 0, 
    FixedTime = 1, 
    Periodical = 2, 
}

export enum RoundingType {
    None = 0, 
    Upward = 1, 
    Downward = 2, 
    Mathematic = 3, 
}

export class TimeLimitationsSelectRequest extends SelectRequestBaseOfInstallationFilter implements ITimeLimitationsSelectRequest {

    constructor(data?: ITimeLimitationsSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TimeLimitationsSelectRequest {
        let result = new TimeLimitationsSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeLimitationsSelectRequest extends ISelectRequestBaseOfInstallationFilter {
}

export class SelectResponceBaseOfTimeLimitationView implements ISelectResponceBaseOfTimeLimitationView {
    data?: TimeLimitationView[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfTimeLimitationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TimeLimitationView.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfTimeLimitationView {
        let result = new SelectResponceBaseOfTimeLimitationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfTimeLimitationView {
    data?: TimeLimitationView[] | undefined;
    total: number;
}

export class TimeLimitationsSelectResponce extends SelectResponceBaseOfTimeLimitationView implements ITimeLimitationsSelectResponce {

    constructor(data?: ITimeLimitationsSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TimeLimitationsSelectResponce {
        let result = new TimeLimitationsSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeLimitationsSelectResponce extends ISelectResponceBaseOfTimeLimitationView {
}

/** Represents T:Jade.Api.Database.TimeLimitation view with referenced entity names */
export class TimeLimitationView extends TimeLimitation implements ITimeLimitationView {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.TimeLimitation.InstallationId */
    installationName?: string | undefined;

    constructor(data?: ITimeLimitationView) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.canWrite = data["canWrite"];
            this.installationName = data["installationName"];
        }
    }

    static fromJS(data: any): TimeLimitationView {
        let result = new TimeLimitationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canWrite"] = this.canWrite;
        data["installationName"] = this.installationName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents T:Jade.Api.Database.TimeLimitation view with referenced entity names */
export interface ITimeLimitationView extends ITimeLimitation {
    /** True if current user has write access for current record */
    canWrite: boolean;
    /** Represents P:Jade.Api.Database.Installation.Name of T:Jade.Api.Database.Installation referenced by P:Jade.Api.Database.TimeLimitation.InstallationId */
    installationName?: string | undefined;
}

export class SelectRequestBaseOfGetUsersRequestFilter implements ISelectRequestBaseOfGetUsersRequestFilter {
    filter: GetUsersRequestFilter = new GetUsersRequestFilter();
    page: Paginator = new Paginator();

    constructor(data?: ISelectRequestBaseOfGetUsersRequestFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"] ? GetUsersRequestFilter.fromJS(data["filter"]) : new GetUsersRequestFilter();
            this.page = data["page"] ? Paginator.fromJS(data["page"]) : new Paginator();
        }
    }

    static fromJS(data: any): SelectRequestBaseOfGetUsersRequestFilter {
        let result = new SelectRequestBaseOfGetUsersRequestFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISelectRequestBaseOfGetUsersRequestFilter {
    filter: GetUsersRequestFilter;
    page: Paginator;
}

export class UsersSelectRequest extends SelectRequestBaseOfGetUsersRequestFilter implements IUsersSelectRequest {

    constructor(data?: IUsersSelectRequest) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): UsersSelectRequest {
        let result = new UsersSelectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUsersSelectRequest extends ISelectRequestBaseOfGetUsersRequestFilter {
}

export class GetUsersRequestFilter extends FilterBase implements IGetUsersRequestFilter {
    login?: string | undefined;
    name?: string | undefined;

    constructor(data?: IGetUsersRequestFilter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.login = data["login"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetUsersRequestFilter {
        let result = new GetUsersRequestFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["name"] = this.name;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetUsersRequestFilter extends IFilterBase {
    login?: string | undefined;
    name?: string | undefined;
}

export class SelectResponceBaseOfUserData implements ISelectResponceBaseOfUserData {
    data?: UserData[] | undefined;
    total: number;

    constructor(data?: ISelectResponceBaseOfUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(UserData.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): SelectResponceBaseOfUserData {
        let result = new SelectResponceBaseOfUserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface ISelectResponceBaseOfUserData {
    data?: UserData[] | undefined;
    total: number;
}

export class UsersSelectResponce extends SelectResponceBaseOfUserData implements IUsersSelectResponce {

    constructor(data?: IUsersSelectResponce) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): UsersSelectResponce {
        let result = new UsersSelectResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUsersSelectResponce extends ISelectResponceBaseOfUserData {
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}